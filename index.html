<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git | GitHub</title>
</head>
<body>
    <h1>Git & GitHub | Class #1</h1>
        <p>
            Git es un sistema de control de versiones distribuido que te permite registrar los<br/> 
            cambios que haces en tus archivos y volver a versiones anteriores si algo sale mal.<br/>
            Fue diseñado por Linus Torvalds para garantizar la eficiencia y confiabilidad del<br/>
            mantenimiento de versiones de aplicaciones que tienen un gran número de archivos de código fuente.
        </p>

        <ul>
            <li>Git está optimizado para guardar cambios de forma incremental.</li>
            <li>Permite contar con un historial, regresar a una versión anterior y agregar funcionalidades.</li>
            <li>Lleva un registro de los cambios que otras personas realicen en los archivos.
        </ul>
            
        <p>
           Git fue diseñado para operar en un entorno Linux. Actualmente, es multiplataforma, es decir, es compatible con Linux, MacOS y<br/>
           Windows. En la máquina local se encuentra Git, se utiliza bajo la terminal o línea de comandos y tiene comandos como merge,<br/>  
           pull, add, commit y rebase, entre otros.
        </p>

    <h3>Para qué proyectos sirve Git</h3>
        <p>
            Con Git se obtiene una mayor eficiencia usando archivos de texto plano, ya que con<br/> 
             archivos binarios no puede guardar solo los cambios, sino que debe volver a grabar<br/> 
            el archivo completo ante cada modificación, por mínima que sea, lo que hace que<br/>  
            incremente demasiado el tamaño del repositorio.
        </p>

    <h3>Características de Git</h3>
        <p>
            Git te ayuda a trabajar de manera más organizada y colaborativa en proyectos de desarrollo de software.<br/>
            Estas son algunas de sus principales características:
        </p>

    <h3>Control de versiones</h3>
        <p>
            Git almacena la información como un conjunto de archivos. Te permite llevar un<br/>
            registro de los cambios que haces en tus archivos, lo que significa que siempre<br/>
            puedes volver a versiones anteriores si algo sale mal.
        </p>

    <h3>Ramificación</h3>
        <p>
            Puedes crear ramas en tu proyecto, lo que te permite trabajar en diferentes<br/>
           características o aspectos del mismo sin afectar el trabajo de los demás.
        </p>

    <h3>Colaboración</h3>
        <p>
            En Git, varias personas pueden trabajar en diferentes aspectos del proyecto al<br/>
            mismo tiempo.
        </p>

    <h3>Seguridad</h3>
        <p>
            No existen cambios, corrupción en archivos o cualquier alteración sin que Git lo<br/>
            sepa. Git cuenta con 3 estados en los que es posible localizar archivos: Staged,<br/>
            Modified y Committed.
        </p>

    <h3>Flexibilidad</h3>
        <p>
            Casi todo en Git es local. Es difícil que se necesiten recursos o información<br/>
            externos, basta con los recursos locales con los que cuenta.
        </p>

    <h3>Comandos</h3>
        <p>
            Git tiene una sintaxis de comandos bastante sencilla y fácil de aprender, lo que lo<br/>
            hace accesible incluso para principiantes en programación.
        </p>

    <h3>¿Qué es un sistema de control de versiones?</h3>
        <p>
            El SCV o VCS (por sus siglas en inglés) es un sistema que registra los cambios<br/>
            realizados sobre un archivo o conjunto de archivos a lo largo del tiempo, de modo<br/>
            que puedas llevar el historial del ciclo de vida de un proyecto, comparar cambios a<br/>
            lo largo del tiempo, ver quién los realizó o revertir el proyecto entero a un estado<br/>
            anterior.
        </p>

    <h3>Características de Github</h3>
        <ul>
            <li>GitHub permite alojar proyectos en repositorios de forma gratuita y pública, pero tiene una forma de pago para privados.</li>
            <li>Puedes compartir fácilmente tus proyectos.</li>
            <li>Permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos.</li>
            <li>Ayuda a reducir significativamente los errores humanos, a tener un mejor mantenimiento de distintos entornos y a detectar fallos de una forma más rápida y eficiente.</li>
            <li>Es la opción perfecta para poder trabajar en equipo en un mismo proyecto.</li>
            <li>Ofrece todas las ventajas del sistema de control de versiones Git, pero también tiene otras herramientas que ayudan a tener un mejor control de los proyectos.</li>
         </ul>

    <h1>Git & GitHub | Class #2</h1>
    
    <h2>Editores de código, archivos binarios y de texto plano</h2>
        <p>
            Un editor de código o IDE es una herramienta que nos brinda muchas ayudas para escribir código, algo así como un bloc de<br>
            muy avanzado. Los editores más populares son
        </p>

        <ul>
            <li>Atom</li>
            <li>Sublime</li>
            <li>Visual Studio code (es el mas popular y usado)</li>
        </ul>
    
    <h3>Tipos de archivos y sus diferencias:</h3>
        <ul>
            <li>Archivos de Texto (<b>.txt</b>): Texto plano normal y sin nada especial. Lo vemos igual<br>
                sin importar dónde lo abramos, ya sea con el bloc de notas o con editores<br>
                de texto avanzados.
            </li><br>
            
            <li>Archivos RTF (<b>.rtf</b>): Podemos guardar texto con diferentes tamaños, estilos y<br>
                colores. Pero si lo abrimos desde un editor de código, vamos a ver que es<br>
                mucho más complejo que solo el texto plano. Esto es porque debe guardar<br>
                todos los estilos del texto y, para esto, usa un código especial un poco difícil de<br>
                entender y muy diferente a los textos con estilos especiales al que estamos<br>
                acostumbrados.
            </li><br>
            
            <li>Archivos de Word (<b>.docx</b>): Podemos guardar imágenes y texto con diferentes<br>
                tamaños, estilos o colores. Al abrirlo desde un editor de código podemos ver<br>
                que es código binario, muy difícil de entender y muy diferente al texto al que<br>
                estamos acostumbrados. Esto es porque Word está optimizado para entender<br>
                este código especial y representarlo gráficamente.
            </li>    
        </ul>

        <p>
            Debemos recordar habilitar la opción de ver la extensión de los archivos, de lo contrario, solo podremos ver su nombre.<br>
            La forma de hacerlo en Windows es <b>Vista > Mostrar u ocultar > Extensiones de nombre de archivo</b>.
        </p>

    <h3>Conceptos importantes de Git</h3>
        <ul>
            <li> <b>Bug</b>: Error en el código</li><br>

            <li> <b>Repository</b>: Donde se almacena todo el proyecto, el cual puede vivir tanto en local como en<br>
                remoto. El repositorio guarda un historial de versiones y, más<br>
                importante, de la relación de cada versión con la anterior para que pueda<br> 
                hacerse el árbol de versiones con las diferentes ramas.
            </li><br>

            <li> <b>Clone</b>: Una vez se decide hacer un fork , hasta ese momento sólo existe en<br>
                GitHub. Para poder trabajar en el proyecto, toca clonar el repositorio elegido al<br>
                computador personal.
            </li><br>

            <li> <b>Branch</b>: Es una bifurcación del proyecto que se está realizando para anexar una<br>
                nueva funcionalidad o corregir un bug.
            </li><br>

            <li> <b>Master</b>: Rama donde se almacena la última versión estable del proyecto que se<br>
                está realizando. La rama master es la que está en producción en cada momento<br>
                (o casi) y debería estar libre de bugs. Así, si esta rama está en producción, sirve<br>
                como referente para hacer nuevas funcionalidades y/o arreglar bugs de última hora.
            </li><br>

            <li> <b>Commit</b>: consiste en subir cosas a la versión local del repositorio. De esta<br>
                manera se puede trabajar en la rama de forma local sin tener que modificar<br>
                ninguna versión en remoto ni tener que tener la última versión remota, cosa<br>
                muy útil en grandes desarrollos trabajados por varias personas.
            </li><br>

            <li> <b>Push</b>: Consiste en enviar todo lo que se ha confirmado con un commit al<br>
                repositorio remoto. Aquí es donde se une nuestro trabajo con el de los demás.
            </li><br>

            <li> <b>Checkout</b>: Acción de descargarse una rama del repositorio GIT local (sí, GIT<br>
                tiene su propio repositorio en local para poder ir haciendo commits) o remoto.
            </li><br>

            <li> <b>Fetch</b>: Actualiza el repositorio local bajando datos del repositorio remoto al<br>
                repositorio local sin actualizarlo, es decir, se guarda una copia del repositorio<br>
                remoto en el local.
            </li><br>
                
            <li> <b>Merge</b>: La acción de merge es la continuación natural del fetch. El merge<br>
                permite unir la copia del repositorio remoto con tu repositorio local, mezclando<br>
                los diferentes códigos.
            </li><br>

            <li> <b>Pull</b>: Consiste en la unión del fetch y del merge, esto es, recoge la información<br>
                del repositorio remoto y luego mezcla el trabajo en local con esta.
            </li><br>

            <li> <b>Diff</b>: Se utiliza para mostrar los cambios entre dos versiones del mismo archivo.</li><br>
        </ul>

    <h1>Git & GitHub | Class #3</h1>
        <ul>
            <li>Para inicializar el repositorio git y el staged: <b>git init</b> </li>
            <li>Enviar el archivo al staged: <b>git add nombre_del_archivo.txt</b> </li>
            <li>Ver el estado, si se requiere agregar al starget o si se requiere commit: <b>git status</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf --list</b> </li>
            <li>Para mostrar las configuraciones y sus rutas: <b>para mostrar las configuraciones y sus rutas</b> </li>
            <li>Para eliminar el archivo del staged(ram): <b>git rm --cached nombre_del_archivo.txt</b> </li>
            <li>Para eliminar del repositorio: <b>para eliminar del repositorio</b> </li>
        </ul>

        <p>
            Recuerda que Git está optimizado para trabajar en equipo, por lo tanto, debemos<br>
            darle un poco de información sobre nosotros. No debemos hacerlo todas las veces<br>
            que ejecutamos un comando, basta con ejecutar solo una sola vez los siguientes<br>
            comandos con tu información:
        </p>

        <ul>
            <li>git config --global user.email "tu@email.com"</li>
            <li>git config --global user.name "Tu Nombre"</li>
         </ul>

         <p>
            Si por algún motivo te equivocaste en el nombre o email que configuraste al principio, lo puedes modificar de la siguiente manera:
         </p>

         <ul>
            <li>git config --global --replace-all user.name “Aquí va tu nombre modificado”</li>
         </ul>

         <p>
            O si lo deseas eliminar y añadir uno nuevo
        </p>

        <ul>
            <li>git config --global --unset-all user.name :Elimina el nombre del usuario</li>
            <li>git config --global --add user.name “Aquí va tu nombre”</li>
        </ul>

    <h1>Git & GitHub | Class #4</h1>
        <h2>Analizar cambios en los archivos de tu proyecto con Git</h2>
        <ul>
            <li>Mostrar cambios que exiten en un archivo: <b>git show</b> </li>
            <li>Guardar cambios de un archivo: <b>git add .</b> </li>
            <li>Agregamos los cambios para el repositorio: <b>git commit -m “Mensaje”</b> </li>
            <li>Histórico de cambios con detalles: <b>git log nombre_de_archivos.extensión</b> </li>
            <li>Envía a otro repositorio remoto lo que estamos haciendo: <b>git push</b> </li>
            <li>Ver diferencias de un commit a otro commit: <b>git diff (identificador-de-commit) (identificador-de-commit)</b></li>
        </ul>

    <h1>Git & GitHub | Class #5</h1>

    <h2>¿Qué es el staging?</h2>
        <p>
            El staging es el lugar donde se guardan temporalmente los cambios, para luego ser<br>
            llevados definitivamente al repositorio. El repositorio es el lugar donde se guardan<br>
            todos los registros de los cambios realizados a los archivos.
        </p>

    <h3>¿Qué es el área de staging?</h3>
        <p>
            El área de staging se puede ver como un limbo donde nuestros archivos están por ser<br>
            enviados al repositorio o ser regresados a la carpeta del proyecto.
        </p>

    <h3>Cómo funciona el staging y el repositorio: ciclo básico de trabajo en git:</h3>
        <ul>
            <p>
                El flujo de trabajo básico en git es algo así:
            </p>

            <li>Modificas una serie de archivos en tu directorio de trabajo.</li>
            <li>Preparas los archivos, añadiéndolos a tu área de preparación (staging).</li>
            <li>Confirmas los cambios (commit), lo que toma los archivos tal y como están en el área de preparación y almacena 
                esa copia instantánea de manera permanente en tu directorio de git.</li>
        </ul>

        <p>Veamos a detalle las 3 secciones principales que tiene un proyecto en git.</p>

    <h3> <u>Working directory</u></h3>
        <p>
            El working directory es una copia de una versión del proyecto. Estos archivos se sacan<br>
            de la base de datos comprimida en el directorio de git y se colocan en el disco para<br>
            que los puedas usar o modificar.
        </p>

    <h3> <u>Staging area</u></h3>
        <p>
            Es un área que almacena información acerca de lo que va a ir en tu próxima confirmación. A veces se le denomina índice (index).
        </p>

    <h3> <u>.git directory (repository)</u></h3>
        <p>
            En el repository se almacenan los metadatos y la base de datos de los objetos para tu<br>
            proyecto. Es la parte más importante de git (carpeta .git) y es lo que se copia cuando<br>
            clonas un repositorio desde otra computadora.
        </p>

    <h3>Ciclo de vida o estados de los archivos en git</h3>
        <p>
            Cuando trabajamos con git, nuestros archivos pueden vivir y moverse entre 4<br>
            diferentes estados (cuando trabajamos con repositorios remotos pueden ser más<br>
            estados):
        </p>

    <h3> <u>Archivos tracked</u></h3>
        <p>
            Son los archivos que viven dentro de git, no tienen cambios pendientes y sus últimas<br>
            actualizaciones han sido guardadas en el repositorio gracias a los comandos <b>git add</b> y <b>git commit</b>.
        </p>

    <h3> <u>Archivos staged</u></h3>
        <p>
            Son archivos en staging. Viven dentro de git y hay registro de ellos porque han sido<br>
            afectados por el comando <b>git add</b>, aunque no sus últimos cambios. Git ya sabe de la<br>
            existencia de estos últimos cambios, pero todavía no han sido guardados definitivamente en<br>
            el repositorio porque falta ejecutar el comando <b>git commit</b>.
        </p>

    <h3> <u>Archivos unstaged</u></h3>
        <p>
            Entiéndelos como archivos “tracked pero unstaged”. Son archivos que viven dentro<br>
            de git pero no han sido afectados por el comando <b>git add</b> ni mucho menos por <b>git commit</b>.<br>
            Git tiene un registro de estos archivos, pero está desactualizado, sus últimas<br>
            versiones solo están guardadas en el disco duro.
        </p>

    <h3> <u>Archivos untracked</u></h3>
        <p>
            Son archivos que NO viven dentro de git, solo en el disco duro. Nunca han sido<br>
            afectados por <b>git add</b>, así que git no tiene registros de su existencia.
        </p>
        <p>
            Recordar que hay un caso muy raro donde los archivos tienen dos estados al mismo<br>
            tiempo: staged y untracked. Esto pasa cuando guardamos los cambios de un archivo en<br>
            el área de staging (con el comando <b>git add</b>), pero antes de hacer commit para<br>
            guardar los cambios en el repositorio haces nuevos cambios que todavía no han sido<br>
            guardados en el área de staging.
        </p>

    <h1>Git & GitHub | Class #6</h1>

    <h2>¿Qué es branch (rama) y cómo funciona un Merge en Git?</h2>
    
        <p>
            Una <b>rama</b> o <b>branch</b> es una versión del código del proyecto sobre el que estás trabajando. Estas<br>
            ramas ayudan a mantener el orden en el control de versiones y manipular el código de forma segura.<br>
        </p>

    <h3>Clases de branches o ramas en Git</h3>
        <p>
            Estas son las ramas base de un proyecto en Git:
        </p>

    <h3> <u>1. Rama main (Master)</u> </h3>
        <p>
            Por defecto, el proyecto se crea en una rama llamada Main (anteriormente conocida como Master).<br>
            Cada vez que añades código y guardas los cambios, estás haciendo un commit, que es añadir el nuevo<br>
            código a una rama. Esto genera nuevas versiones de esta rama o branch, hasta llegar a la versión actual de la rama Main.
        </p>
    
    <h3> <u>2. Rama development</u> </h3>
        <p>
            Cuando decides hacer experimentos, puedes generar ramas experimentales<br>
            (usualmente llamadas development), que están basadas en alguna rama main, pero<br>
            sobre las cuales puedes hacer cambios a tu gusto sin necesidad de afectar directamente al código principal.
        </p>

    <h3> <u>3. Rama hotfix</u> </h3>
        <p>
            En otros casos, si encuentras un bug o error de código en la rama Main (que afecta al<br>
            proyecto en producción), tendrás que crear una nueva rama (que usualmente se<br>
            llaman bug fixing o hot fix) para hacer los arreglos necesarios. Cuando los cambios<br>
            estén listos, los tendrás que fusionar con la rama Main para que los cambios sean<br>
            aplicados. Para esto, se usa un comando llamado <b>Merge</b>, que mezcla los cambios de<br>
            la rama que originaste a la rama <b>Main</b>.
        </p>
        <p>
            <b>Todos los commits se aplican sobre una rama</b>. Por defecto, siempre empezamos en<br>
            la rama Main (pero puedes cambiarle el nombre si no te gusta) y generamos nuevas<br>
            ramas, a partir de esta, para crear flujos de trabajo independientes.
        </p>

    <h1>Git & GitHub | Class #7</h1>

    <h2>Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h2>
        <ul>
            <li>Nos muestra el historial de commits hechos de el mas reciente hasta el mas viejo: <b>git log</b> </li>
            <li>Nos muestra el historial de cambios especificos de cada commit desde el mas reciete hasta el mas viejo: <b>git log --stat</b> </li>
            <li>Muestra los cambios hechos al archivo en el ultimo commit: <b>git show (nombre_del_archivo)</b> </li>
            <li>Nos muestra las diferencias entres los cambios que estan en Staging y los que aun no se han añadido: <b>git diff</b> </li>
            <li>Nos muestra las diferencias entre las dos versiones de los commits: <b>git diff (id-del-commit) (id-del-commit)</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, pero sin borrar los commits usados anteriormente: <b>git reset (id-del-commit) --soft</b> </li>
            <li>Volvemos nuestro archivo a la version del commit indicada, BORRANDO TODOS los commits usados anteriores a la version del commit indicada: <b>git reset (id-del-commit) --hard</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, sin cambiar nada en el Staging: <b>git checkout (id-del-commit) (nombre_del_archivo)</b> </li>
            <li>Volvemos a nuestro archivo a la version que teniamos antes de hacer el primer checkout, sin cambiar nada en el Staging: <b>git checkout master (nombre_del_archivo)</b> </li>
        </ul>

    <h1>Git & GitHub | Class #8</h1>
    
    <h2>Git reset vs. Git rm</h2>
        <p>
            Los comandos git reset y git rm tienen utilidades muy diferentes, pero pueden confundirse fácilmente.
        </p>

    <h3>Git reset</h3>
        <p>
            El comando <b>git reset</b> es una herramienta poderosa que te permite deshacer o<br>
            revertir cambios en tu repositorio de Git. Lo puedes ejecutar de tres maneras<br>
            diferentes, con las líneas de comando <b>--soft</b>, <b>--mixed</b> y  <b>--hard</b>.
        </p>
        <p>
            Pero no como <b>git checkout</b> que nos deja ir, mirar, pasear y volver. Con <b>git reset</b><br>
            volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia<br> 
            y la debemos sobreescribir. No hay vuelta atrás.
        </p>

    <h3>Variaciones de Git Reset</h3>
        <ul>
            <li>Borra el historial y los registros de Git de commits anteriores, pero guarda los cambios en Staging para aplicar las últimas actualizaciones a un nuevo commit: <b>git reset --soft</b> </li>
            <li>Deshace todo, absolutamente todo. Toda la información de los commits y del área de staging se elimina del historial: <b>git reset --hard</b> </li>
            <li>Borra todo, exactamente todo. Toda la información de los commits y del área de staging se elimina del historial.: <b>git reset --mixed</b> </li>
            <li>El comando git reset saca archivos del área de staging sin borrarlos ni realizar otras acciones. Esto impide que los últimos cambios en estos archivos se envíen al último commit. Podemos incluirlos de nuevo en staging con git add si cambiamos de opinión <b>git reset HEAD</b> </li>
        </ul>

    <h3>¿Qué es git reset HEAD?</h3>
        <p>
            git reset HEAD es un comando que te permite revertir los cambios que ya habías<br>
            preparado para subir, y moverlos de vuelta a tu proyecto. Con este comando puedes<br>
            cancelar los cambios que ya habías agregado, para que puedas revisarlos, modificarlos o<br>
            deshacerlos antes de confirmarlos con un commit.
         </p>

    <h3>Git rm</h3>
        <p>
            Por otro lado, git rm es un comando que nos ayuda a eliminar archivos de Git<br>
            sin eliminar su historial del sistema de versiones. Para recuperar el archivo<br>
            eliminado, necesitamos retroceder en la historia del proyecto, recuperar el último commit<br>
            y obtener la última confirmación antes de la eliminación del archivo.
        </p>

    <h3>Variaciones de Git rm</h3>
        <ul>
            <li>Elimina archivos del repositorio local y área de staging, pero los mantiene en el disco duro. Deja de trackear el historial de cambios de estos archivos, lo cual queda en estado untracked: <b>git rm --cached</b> </li>
            <li>Elimina los archivos de Git y del disco duro. Git guarda todo, por lo que podemos recuperar archivos eliminados si es necesario (empleando comandos avanzados): <b>git rm --force</b> </li>    
        </ul>
        
    <h3>¿Cuál es la diferencia entre git rm y git reset Head?</h3>
        <p>
            La diferencia principal entre git rm y git reset HEAD radica en que git rm<br>
            elimina archivos del repositorio y de la historia del proyecto, mientras que git<br>
            reset saca los cambios del área de preparación y los mueve del espacio de trabajo, <br>
            sin afectar la historia del repositorio.
        </p>

    <h1>Git & GitHub | Class #9</h1>

    <h2>Flujo de trabajo básico con un repositorio remoto</h2>
        <p>
            Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu<br>
            computadora. Esto significa que no hay forma de que otros miembros del equipo trabajen en él.<br><br>

            Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben<br>
            seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.<br><br>

            Estos servidores remotos pueden estar alojados en GitHub, GitLab, BitBucket, entre<br>
            otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu<br>
            computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto.<br>
            Así, el equipo podrá descargarlos, hacer cambios y volverlos a enviar al servidor remoto para<br>
            que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.<br><br>

            Esto significa que debes aprender algunos nuevos comandos
        </p>

    <h3>Comandos para trabajo remoto con GIT</h3>
        <ul>
            <li>Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta: <b>git clone (url_del_servidor_remoto)</b> </li>
            <li>Luego de hacer <b>git add</b> y <b>git commit</b> debemos ejecutar este comando para mandar los cambios al servidor remoto: <b>git push</b> </li>
            <li>Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto): <b>git fetch</b> </li>
            <li>También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo: <b>git merge</b> </li>
            <li>Básicamente, <b>git fetch</b> y <b>git merge</b> al mismo tiempo: <b>git pull</b> </li>
        </ul>

        <p>
            Adicionalmente, tenemos otros comandos que nos sirven para trabajar en proyectos muy grandes:
        </p>
        
        <ul>
            <li>Te muestra el id commit y el título del commit: <b>git log --oneline</b> </li>
            <li>Te muestra donde se encuentra el head point en el log: <b>git log --decorate</b> </li>
            <li>Explica el número de líneas que se cambiaron brevemente: <b>git log --stat</b> </li>
            <li>Explica el número de líneas que se cambiaron y te muestra que se cambió en el contenido: <b>git log -p</b> </li>
            <li>Indica que commits ha realizado un usuario, mostrando el usuario y el título de sus commits: <b>git shortlog</b> </li>
            <li> <b>git log --graph --oneline --decorate</b> y <b>git log --pretty=format:"%cn hizo un commit %h el dia %cd"</b>: Muestra mensajes personalizados de los commits</li>
            <li>Limitamos el número de commits: <b>git log -3</b> </li>
            <p>
                Commits para localizar por fechas:
            </p>
            <li> <b>git log --after=“2018-1-2</b> </li>
            <li> <b>git log --after=“today</b> </li>
            <li> <b>git log --after=“2018-1-2” --before=“today”</b> </li> <br>
            <li>Commits hechos por autor que cumplan exactamente con el nombre: <b>git log --author=“Name Author”</b> </li>
            <li>Busca los commits que cumplan tal cual está escrito entre las comillas: <b>git log --grep=“INVIE”</b> </li>
            <li>Busca los commits que cumplan sin importar mayúsculas o minúsculas: <b>git log --grep=“INVIE” –i</b> </li>
            <li>Busca los commits en un archivo en específico: <b>git log – (nombre_del_archivo)</b> </li>
            <li>Buscar los commits con el contenido dentro del archivo: <b>git log -S “Por contenido”</b> </li>
            <li>Guardar los logs en un archivo txt: <b>git log > log.txt</b> </li>
        </ul>

    <h1>Git & GitHub | Class #10</h1>

    <h2>Introducción a las ramas o branches de Git</h2>
            <p>
                Las ramas (branches) son la forma de hacer cambios en nuestro proyecto sin afectar<br>
                el flujo de trabajo de la rama principal. Esto porque queremos trabajar una parte muy<br>
                específica de la aplicación o simplemente experimentar.<br><br>

                La cabecera o <b>HEAD</b> representan la rama y el commit de esa rama donde estamos<br>
                trabajando. Por defecto, esta cabecera aparecerá en el último commit de nuestra<br>
                rama principal. Pero podemos cambiarlo al crear una rama (<b>git branch rama</b>, <b>git checkout -b rama</b>)<br>
                o movernos en el tiempo a cualquier otro commit de cualquier otra rama con los comandos<br>
                (<b>git reset id-commit</b>, <b>git checkout rama-o-id-commit</b>).
            </p>
    
    <h3>Cómo funcionan las ramas en GIT</h3>
            <p>
                Las ramas son la manera de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de<br>
                la rama principal. Esto porque queremos trabajar una parte muy específica<br>
                de la aplicación o simplemente experimentar.
            </p>

            <ul>
                <li>Agrega los archivos al <b>Git Repository</b> desde el <b>Working Directory</b>, solo funciona si los archivos previamente se les a echo <b>git add</b> previamente: <b>git commit -am "mensaje del commit"</b> </li>
                <li>Con este comando se genera una nueva rama: <b>git branch (nombre-de-la-rama)</b> </li>
                <li>Lista todas las ramas que existen: <b>git branch -i</b> </li>
                <li>Con este comando puedes saltar de una rama a otra: <b>git checkout (nombre-de-la-rama)</b> </li>
                <li>Elimina la rama. Con <b>-D</b> se fuerza el borrado: <b>git branch -d (nombre-de-la-rama)</b> </li>
                <li>Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de git branch y git checkout al mismo tiempo: <b>git checkout -b (nombre-de-la-rama)</b> </li>
                <li>Permite renombrar una rama en una nueva rama: <b>git branch -m (nombre-de-la-rama) (nombre-de-la-nueva-rama)</b> </li>
                <li>Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag., eliminando el historial de los commit posteriores al tag seleccionado: <b>git reset (id-commit)</b> </li>
                <li>Nos lleva a cualquier commit sin borrar los commit posteriores al tag seleccionado: <b>git checkout (rama-o-id-commit)</b> </li>
            </ul>

    <h1>Git & GitHub | Class #11</h1>
    
    <h2>Fusión de ramas con Git merge</h2>
            <p>
                La fusión en Git es la forma en que este sistema une un historial bifurcado.<br>
                El comando <b>git merge</b> permite integrar líneas de desarrollo independientes generadas<br>
                por <b>git branch</b> en una sola rama. Con este comando, podemos crear un nuevo commit que combina<br>
                dos ramas o branches: la rama actual y la rama que se indica después del comando.<br><br>

                Estos comandos de fusión del merge afectan solo a la rama actual y no a la rama de destino.<br>
                Por lo tanto, te recomendamos utilizar <b>git checkout</b> para seleccionar la rama actual y <b>git branch -d</b><br>
                para eliminar la rama de destino obsoleta.
            </p>
    <h3>Funcionamiento de Git merge</h3>
            <p>
                Git merge fusiona secuencias de confirmaciones en un solo historial, generalmente para combinar<br>
                dos ramas. Busca una confirmación de base común y genera una confirmación de fusión que representa<br>
                la combinación de las dos ramas hasta el resultado final.
            </p>

    <h3>¿Cómo unir dos ramas en git?</h3>
            <p>
                Ahora bien, para combinar ramas en tu repositorio local, usa git checkout para cambiar a la rama donde deseas<br>
                fusionar. Por lo general, esta es la rama principal. Luego, emplea git merge y especifica el nombre de la otra<br>
                rama que deseas traer a esta rama. Ten en cuenta que esto es una combinación de avance rápido.
            </p>

    <h3>¿Cómo realizar un merge en git?</h3>
            <p>
                Para hacer un merge en Git, primero asegúrate de estar en la rama correcta. Después, usa el comando <b>git merge</b> seguido<br>
                del nombre de la rama que quieres combinar. Por ejemplo, si quieres crear un nuevo commit en la rama master con los<br>
                cambios de la rama cabecera, usa este comando:
            </p>

            <ul>
                <li> <b>git checkout master</b> </li>
                <li> <b>git merge cabecera</b> </li>
            </ul>

            <p>
                Es importante tener en cuenta que en caso de haber conflictos, debes guardar tus<br>
                cambios antes de hacer <b>git checkout</b> para evitar perder tu trabajo. También es recomendable<br>
                emplear los comandos básicos de GitHub, como <b>git fetch</b>, <b>git push</b> y <b>git pull</b>, para mantener actualizado tu repositorio.<br><br>

                En este ejemplo, vamos a crear un nuevo commit en la rama master combinando los cambios de una rama<br>
                llamada cabecera: Otra opción es crear un nuevo commit en la rama cabecera combinando los cambios de cualquier otra rama:<br><br>

                Git es asombroso porque puede saber cuáles cambios deben conservarse en una rama y cuáles no.<br>
                En casos de conflictos, asegúrate de guardar tus cambios antes de hacer <b>git checkout</b> para evitar perder tu trabajo.
            </p>

    <h1>Git & GitHub | Class #12</h1>
        
    <h2>Resolución de conflictos al hacer un merge</h2>
            <p>
                Git nunca borra nada, a menos que nosotros se lo indiquemos. Cuando usamos los comandos <b>git merge</b> o<br>
                <b>git checkout</b> estamos cambiando de rama o creando un nuevo commit, no borrando ramas ni commits<br>
                (recuerda que puedes borrar commits con <b>git reset</b> y ramas con <b>git branch -d</b>).<br><br>
        
                Git es muy inteligente y puede resolver algunos conflictos automáticamente: cambios, nuevas líneas, entre otros.<br>
                Pero algunas veces no sabe cómo resolver estas diferencias, por ejemplo, cuando dos ramas diferentes hacen cambio<br>
                distintos a una misma línea.<br><br>
        
                Esto lo conocemos como <b>conflicto</b> y lo podemos resolver manualmente. Solo debemos hacer el merge, ir a nuestro editor de código<br>
                y elegir si queremos quedarnos con alguna de estas dos versiones o algo diferente. Algunos editores de código como Visual Studio Code<br>
                nos ayudan a resolver estos conflictos sin necesidad de borrar o escribir líneas de texto, basta con hacer clic en un<br>
                botón y guardar el archivo.<br><br>

                Recuerda que siempre debemos crear un nuevo commit para aplicar los cambios del merge. Si Git puede resolver el<br>
                conflicto, hará commit automáticamente. Pero, en caso de no pueda resolverlo, debemos solucionarlo y hacer el commit.<br><br>
        
                Los archivos con conflictos por el comando <b>git merge</b> entran en un nuevo estado que conocemos como<br>
                <b>Unmerged</b>. Funcionan muy parecido a los archivos en estado Unstaged, algo así como un estado intermedio entre Untracked<br>
                y Unstaged. Solo debemos ejecutar <b>git add</b> para pasarlos al área de staging y <b>git commit</b> para aplicar los cambios en el repositorio.
           </p>
        
    <h3>Cómo revertir un merge</h3>
            <p>
                Si nos hemos equivocado y queremos cancelar el merge, debemos usar el siguiente comando:
            </p>
        
            <ul>
                <li> <b>git merge --abort</b> </li>
            </ul>
        
    <h3>Conflictos en repositorios remotos</h3>
            <p>
                Al trabajar con otras personas, es necesario utilizar un repositorio remoto.
            </p>
        
            <ul>
                <li>Para copiar el repositorio remoto al directorio de trabajo local, se utiliza el comando <b>git clone (url)</b>, y para enviar cambios al repositorio remoto se utiliza <b>git push</b>.</li>
                <li>Para actualizar el repositorio local se hace uso del comando <b>git fetch</b>, luego se debe fusionar los datos traídos con los locales usando <b>git merge</b>.</li> <br><br>
        
                <li>Para traer los datos y fusionarlos a la vez, en un solo comando, se usa <b>git pull</b>.</li>
                <li>Para crear commits rápidamente, fusionando <b>git add</b> y <b>git commit -m ""</b>, usamos <b>git commit -am ""</b>.</li>
                <li>Para generar nuevas ramas, hay que posicionarse sobre la rama que se desea copiar y utilizar el comando <b>git branch (nombre)</b></li>
                <li>Para saltar entre ramas, se usa el comando <b>git checkout (branch)</b></li>
                <li>Una vez realizado los cambios en la rama, estas deben fusionarse con <b>git merge</b>.</li>
            </ul>

    <h1>Git & GitHub | Class #13</h1>

    <h2>Cómo funcionan las llaves públicas y privadas</h2>
            <p>
                Las llaves públicas y privadas, conocidas también como cifrado asimétrico de un solo camino, sirven<br>
                para mandar mensajes privados entre varios nodos con la lógica de que firmas tu mensaje con una llave pública<br>
                vinculada con una llave privada que puede leer el mensaje.<br><br>

                Las llaves públicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos<br>
                compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.
            </p>
    
    <h3>Cómo funciona un mensaje cifrado con llaves públicas y privada</h3>
            <ul>
                <li>1. Ambas personas deben crear su llave pública y privada.</li>
                <li>2. Ambas personas pueden compartir su llave pública a las otras partes (recuerda que esta llave es pública, no hay problema si la “interceptan”).</li>
                <li>3. La persona que quiere compartir un mensaje puede usar la llave pública de la otra persona para cifrar los archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos compartir el mensaje.</li>
                <li>4. El mensaje está cifrado y puede ser enviado a la otra persona sin problemas en caso de que los archivos sean interceptados.</li>
                <li>5. La persona a la que enviamos el mensaje cifrado puede emplear su llave privada para descifrar el mensaje y ver los archivos.</li>
            </ul>

            <p>
                <b>Nota: puedes compartir tu llave pública, pero nunca tu llave privada.</b>
            </p>

    <h1>Git & GitHub | Class #13</h1>

    <h2>Configura tus llaves SSH en local</h2>
            <p>
                En este ejemplo, aprenderemos cómo configurar nuestras llaves SSH en local.
            </p>

    <h3>Cómo generar tus llaves SSH</h3>

    <h3>1. Generar tus llaves SSH**</h3>
            <p>
                Recuerda que es muy buena idea proteger tu llave privada con una contraseña.
            </p>
            <ul>
                <li> <b>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</b> </li>
            </ul>

    <h3>2. Terminar de configurar nuestro sistema.</h3>
            <p>
                En Windows y Linux:
            </p>

            <ul>
                <li>Encender el “servidor” de llaves SSH de tu computadora: <b>eval $(ssh-agent -s)</b> </li>
                <li>Añadir tu llave SSH a este “servidor”: <b>ssh-add ruta-donde-guardaste-tu-llave-privada</b> </li>
            </ul>

    <h1>Git & GitHub | Class #14</h1>

    <h2>Uso de GitHub</h2>
            <p>
                GitHub es una plataforma que nos permite guardar repositorios de Git que podemos usar como servidores remotos<br>
                y ejecutar algunos comandos de forma visual e interactiva (sin necesidad de la consola de comandos).
            </p>

    <h3>Cómo conectar un repositorio de GitHub a nuestro documento local</h3>
            <p>
                Si queremos conectar el repositorio de GitHub con nuestro repositorio local, que creamos usando<br>
                el comando <b>git init</b>, debemos ejecutar las siguientes instrucciones:
            </p>

            <ul>
                <li>1. Guardar la URL del repositorio de GitHub con el nombre de origin:<br><br>
                    <b>git remote add origin URL</b>  </li> <br>

                <li>2. Verificar que la URL se haya guardado correctamente: <br><br>

                <b>git remote</b> <br>
                <b>git remote -v</b> </li><br>

                <li>3. Traer la versión del repositorio remoto y hacer merge para crear un<br>
                    commit con los archivos de ambas partes. Podemos usar <b>git fetch</b> y <b>git merge</b><br>
                    o solo <b>git pull</b> con el flag <b>--allow-unrelated-histories</b>: <br><br>

                    <b>git pull origin master</b> --allow-unrelated-histories</li> <br>

                <li>4. Por último, ahora sí podemos hacer <b>git push</b> para guardar los cambios de nuestro repositorio local en GitHub: <br><br>

                    <b>git push origin master</b></li>
            </ul>

    <h1>Git & GitHub | Class #15</h1>
    
    <h2>Cambios en GitHub: de master a main</h2>
            <p>
                El escritor Argentino Julio Cortázar afirma que las palabras tienen color y peso. Por otro lado, los<br>
                sinónimos existen por definición, pero no expresan lo mismo. Feo no es lo mismo que desagradable, ni<br>
                aromático es lo mismo que oloroso.<br><br>

                Por lo anterior podemos afirmar que los sinónimos no expresan lo mismo, no tienen<br>
                el mismo “color” ni el mismo “peso”.<br><br>

                Sí, esta lectura es parte del curso profesional de Git & GitHub. Quédate conmigo.<br><br>

                Desde el 1 de octubre de 2020 GitHub cambió el nombre de la rama principal: ya<br>
                no es “master” -como aprenderás en el curso- sino main.<br><br>

                Este derivado de una profunda reflexión ocasionada por el movimiento #BlackLivesMatter.<br><br>

                La industria de la tecnología lleva muchos años usando términos como master, slave,<br>
                blacklist o whitelist y esperamos pronto puedan ir desapareciendo<br><br>

                Y sí, las palabras importan.<br><br>

                Por lo que de aquí en adelante cada vez que escuches a Freddy mencionar “master”<br>
                debes saber que hace referencia a “main”
            </p>

    <h1>Git & GitHub | Class #16</h1>

    <h2>Git tag y versiones en Github</h2>
            <p>
                En Git, las etiquetas o Git tags tienen un papel importante al asignar versiones<br>
                a los commits más significativos de un proyecto. Aprender a utilizar el comando git tag, entender<br>
                los diferentes tipos de etiquetas, cómo crearlas, eliminarlas y compartirlas, es esencial para un flujo de trabajo eficiente.
            </p>

    <h3>Creación de etiquetas en Git</h3>
            <ul>
                <li>Para crear una etiqueta, ejecuta el siguiente comando: <br><br>
                <b>git tag -a v0.1 -m "Descripcion-de-la-etiqueta" (id-del-commit)</b> </li>
            </ul>

            <p>
                Sustituye <b>(tagname)</b> con un identificador semántico que refleje el estado del<br>
                repositorio en el momento de la creación. Git admite etiquetas anotadas y ligeras.<br><br>

                Las etiquetas anotadas almacenan información adicional como la fecha, etiquetador y correo<br>
                electrónico, y son ideales para publicaciones públicas. Las etiquetas ligeras son más simples y se<br>
                emplean como “marcadores” de una confirmación específica.
            </p>

    <h3>Listado de etiquetas</h3>
            <ul>
                <li>Para obtener una lista de etiquetas en el repositorio, ejecuta el siguiente comando:<br><br>
                <b>git tag</b> </li> <br>

                <li>Esto mostrará una lista de las etiquetas existentes, como:<br><br>
                <b>v1.0</b> <br>
                <b>v1.1</b> <br>
                <b>v1.2</b> </li>
            </ul>

    <h3>Uso compartido de etiquetas</h3>
            <p>
                Compartir etiquetas requiere un enfoque explícito al usar el comando git push. Por<br>
                defecto, las etiquetas no se envían automáticamente. <br><br>
                
                Para enviar etiquetas específicas, utiliza:
            </p>

            <ul>
                <li><b>git push origin (tagname)</b></li>
            </ul>

            <p>
                Para enviar varias etiquetas a la vez, usa:
            </p>

            <ul>
                <li><b>git push origin --tags</b></li>
            </ul>

    <h3>Eliminación de etiquetas</h3>
            <p>
                Para eliminar una etiqueta, usa el siguiente comando:
            </p>

            <ul>
                <li><b>git tag -d (tagname)</b></li>
            </ul>

            <p>
                Esto eliminará la etiqueta identificada por <b>(tagname)</b> en el repositorio local.
            </p>

    <h3>Borar tags que siguen apareciendo en GitHub</h3>
            <p>
                Este comando elimina todas las etiquetas remotas en el repositorio remoto:
            </p>
            
            <ul>
                <li><b>git push origin :refs/tags/(nombre-de-la-etiqueta)</b></li>
            </ul>

    <h2>Un comando adicional</h2>
            <p>
                Este comando es utilizado en Git, un sistema de control de versiones, para visualizar el<br>
                historial de commits de un repositorio de una manera más compacta y gráfica (RAMAS)
            </p>

            <ul>
                <li>
                    <b>git log --all --graph --decorate --oneline</b>
                </li>
            </ul>      
            
    <h1>Git & GitHub | Class #17</h1>

    <h2>Manejo de ramas en GitHub</h2>
            <p>
                Las ramas nos permiten hacer cambios a nuestros archivos sin modificar la versión principal (master).<br>
                Puedes trabajar con ramas que nunca envías a GitHub, así como pueden haber ramas importantes en GitHub<br>
                que nunca usas en el repositorio local. Lo crucial es que aprendas a manejarlas para trabajar profesionalmente.<br><br>

                Si, estando en otra rama, modificamos los archivos y hacemos commit, tanto el historial(git log) como los archivos<br>
                serán afectados. La ventaja que tiene usar ramas es que las modificaciones solo afectarán a esa rama en particular.<br>
                Si luego de “guardar” los archivos(usando <b>commit</b>) nos movemos a otra rama (<b>git checkout</b> otraRama)<br>
                veremos como las modificaciones de la rama pasada no aparecen en la <b>otraRama</b>.
            </p>

    <h3>Comandos para manejo de ramas en GitHub</h3>
            <ul>
                <li>Crear una rama: <br><br>
                    <b>git branch (nombre-de-la-rama)</b>
                </li><br>
        
                <li>Movernos a una rama: <br><br>
                    <b>git checkout (nombre-de-la-rama)</b>
                </li><br>
                    
                <li>Crear una rama en el repositorio local: <br><br>
                    <b>git branch nombre-de-la-rama</b> o <b>git checkout -b nombre-de-la-rama</b>
                </li><br>
        
                <li>Publicar una rama local al repositorio remoto: <br><br>
                    <b>git push origin (nombre-de-la-rama)</b>
                </li>
            </ul>

            <p>
                Podemos ver gráficamente nuestro entorno y flujo de trabajo local con Git utilizando el comando <b>gitk</b>. Gitk fue<br>
                el primer visor gráfico que se desarrolló para ver de manera gráfica el historial de un repositorio de Git.
            </p>
    
    <h3>Comandos importantes para manejar ramas</h3>
            <ul>
                <li>Nos muestra cuales son las ramas que existen y cual es su historia: <br><br>
                    <b>git show-branch</b>
                </li><br>
    
                <li>Es similar al <b>git show-branch</b> pero con mas datos: <br><br>
                    <b>git show-branch --all</b>
                </li>
            </ul>

    <h1>Git & GitHub | Class #18</h1>

    <h2>Configurar múltiples colaboradores en un repositorio de GitHub</h2>
            <p>
                Por defecto, cualquier persona puede clonar o descargar tu proyecto desde GitHub, pero<br>
                no pueden crear commits, ni ramas. Esto quiere decir que pueden copiar tu proyecto pero no<br>
                colaborar con él. Existen varias formas de solucionar esto para poder aceptar contribuciones. Una de<br>
                ellas es añadir a cada persona de nuestro equipo como colaborador de nuestro repositorio.  
            </p>

    <h3>Cómo agregar colaboradores en GitHub</h3>
            <li>Solo debemos entrar a la configuración de colaboradores de nuestro proyecto. Se encuentra en: <br><br>
                <b>Repositorio > Settings > Collaborators</b>
            </li>
            
            <p>
                Ahí, debemos añadir el email o username de los nuevos colaboradores. <br><br>

                Si, como colaborador, agregaste erróneamente el mensaje del commit, lo puedes cambiar de la siguiente manera:
            </p>

            <ul>
                <li>Hacer un commit con el nuevo mensaje que queremos, esto nos abre el editor de texto de la terminal: <br><br>
                    <b>git commit —amend</b><br><br>
                </li>

                <li>Corregimos el mensaje</li><br>

                <li>Traer el repositorio remoto: <br><br>
                    <b>git pull orgin master</b><br><br>
                </li>

                <li>Ejecutar el cambio: <br><br>
                    <b>git push --set-upstream origin master</b>
                </li>
            </ul>

    <h1>Git & GitHub | Class #19</h1>

    <h2>Flujo de trabajo profesional: Haciendo merge de ramas de desarrollo a master</h2>
            <p>
                Para poder desarrollar software de manera óptima y ordenada, necesitamos tener un flujo de<br>
                trabajo profesional, que nos permita trabajar en conjunto sin interrumpir el trabajo de otros desarrolladores. Una<br>
                buena práctica de flujo de trabajo sería la siguiente:
            </p>

            <ul>
                <li>1. Crear ramas</li>
                <li>2. Asignar una rama cada progamador</li>
                <li>3. El progamador baja el repositorio con <b>git pull origin master</b></li>
                <li>4. El programador cambia de rama</li>
                <li>5. El programador trabaja en esa rama y hace commits</li>
                <li>6. El progamador sube su trabajo con <b>git push origin (nombre-de-la-rama)</b></li>
                <li>7. El encargado de organizar el proyecto baja, revisa y unifica todos los cambios</li>
            </ul>

    <h1>Git & GitHub | Class #20</h1>

    <h2>Flujo de trabajo profesional con Pull requests</h2>
            <p>
                En un entorno profesional normalmente se bloquea la rama master, y para enviar código a dicha<br>
                rama pasa por un code review y luego de su aprobación se unen códigos con los llamados merge request.<br><br>

                Para realizar pruebas enviamos el código a servidores que normalmente los llamamos staging develop<br>
                (servidores de pruebas) luego de que se realizan las pruebas pertinentes tanto de código como de la aplicación<br>
                estos pasan al servidor de producción con el ya antes mencionado merge request.<br><br>

                Los PR (pull requests) son la base de la colaboración a proyectos Open Source, si tienen pensando colaborar<br>
                n alguno es muy importante entender esto. Por lo general es forkear<br>
                el proyecto, implementar el cambio en una nueva rama, hacer el PR y esperar que los administradores del proyecto<br>
                hagan el merge o pidan algún cambio en el código o commits que hiciste.
            </p>

    <h3>Proceso de un pull request para trabajo en producción:</h3>
            <ul>
                <li>Un pull request es un estado intermedio antes de enviar el merge.</li>
                <li>El pull request permite que otros miembros del equipo revisen el código y así aprobar el merge a la rama.</li>
                <li>Permite a las personas que no forman el equipo, trabajar y colaborar con una rama.</li>
                <li>La persona que tiene la responsabilidad de aceptar los pull request y hacer los merge tienen un perfil especial y son llamados DevOps</li>
            </ul>

    <h1>Git & GitHub | Class #21</h1>

    <h2>Utilizando Pull Requests en GitHub</h2>
            <p>
                Un Pull Request es una función de GitHub que permite a tu equipo solicitar la revisión y aprobación<br>
                de sus cambios antes de fusionarlos en la rama principal de desarrollo, denominada “master” o “main”.<br><br>

                Al crear un PR se genera una conversación en la que los demás miembros pueden seguir y comentar los cambios propuestos<br>
                en el código del repositorio. Esto permite detectar cualquier error o problema potencial<br>
                antes de integrarlos en la rama principal, lo que ayuda a mantener el proyecto más limpio y estable.
            </p>

    <h3>Estructura de la incorporación de cambios</h3>
            <p>
                El proceso para hacer un pull request consiste en indicar la rama y repositorio de origen y destino. De<br>
                esta forma, un desarrollador podrá incluir tus cambios en su proyecto.<br><br>

                Bitbucket tiene una configuración predeterminada que funciona para la mayoría de los equipos, pero<br>
                cada equipo puede personalizarla para ajustarla a su propio flujo de trabajo.
            </p>

    <h3>Cómo hacer un pull request</h3>
            <p>
                Un PR es un proceso crucial para facilitar la revisión y la integración efectiva del código. A<br>
                continuación, veremos el paso a paso.
            </p>

    <h3>Solicitando un pull request</h3>
            <p>
                <b>1</b>. <b>Crea una rama paralela</b>: Antes de hacer cambios en el código, utiliza el comando <b>git checkout -b (rama)</b> para crear una<br>
                nueva rama. Así, podrás hacer tus modificaciones sin afectar la rama principal (por ejemplo, <b>master</b>).<br><br>

                <b>2</b>. <b>Realiza commits</b>: Después de hacer cambios en los archivos, usa <b>git commit -am '(comentario)'</b> para<br>
                hacer un commit con un mensaje descriptivo.<br><br>

                <b>3</b>. <b>Sube los cambios</b>: Usa <b>git push origin (rama)</b> para subir tus cambios de la rama local al<br>
                repositorio remoto. Reemplaza <b>(rama)</b> con el nombre de tu rama.<br><br>

                <b>4</b>. <b>Crea un pull request</b>: En el repositorio remoto (como GitHub), crea un<br>
                nuevo pull request. Selecciona la rama principal como destino y tu rama con los cambios como comparación.<br><br>

                <b>5</b>. <b>Feedback</b>: Los revisores examinarán los cambios. Usa la sección de comentarios del pull request<br>
                para discutir los cambios y proporcionar feedback adicional.<br><br>

                <b>6</b>. <b>Realiza los cambios solicitados</b>: Si se solicitan cambios, regresa a tu rama local y haz las modificaciones
                necesarias. Luego, sube los cambios al repositorio remoto usando <b>git push origin (rama)</b>.
            </p>

    <h3>Aceptando un pull request</h3>
            <p>
                <b>1</b>. Acepta los cambios en GitHub: Si estás satisfecho con los cambios propuestos en el pull request<br>
                y consideras que están listos para ser fusionados con la rama principal, acepta el pull request en<br>
                GitHub. De esta forma, los cambios se fusionarán en la rama principal del repositorio.<br><br>

                <b>2</b>. Realiza el merge en la rama principal: Después de aceptar el pull request, selecciona la<br>
                opción para realizar el merge en GitHub. Esto combinará los cambios de la rama con los cambios existentes en la rama principal (master).<br><br>

                Para solicitar y aceptar pull requests de manera efectiva, sigue estos sencillos pasos que te ayudarán<br>
                a facilitar la colaboración y la mejora continua del código en tu proyecto.
            </p>

    <h3>¿Cómo corregir un Pull Request?</h3>
            <p>
                Al revisar un pull request, es posible encontrar problemas o áreas que necesiten corrección antes de que<br>
                los cambios se puedan unir con la rama principal. Aquí se explica cómo corregir un pull request de forma efectiva.<br><br>

                <b>1</b>. <b>Lee los comentarios y feedback</b>: Comprueba cuidadosamente todos los comentarios<br>
                y feedback proporcionados por los revisores en el pull request<br><br>

                <b>2</b>. <b>Regresa a tu rama local</b>: Utiliza el comando <b>git checkout (rama)</b> para volver a la rama en la que<br>
                realizaste los cambios y necesitas revisar.<br><br>

                <b>3</b>. <b>Realiza las modificaciones</b>: Basándote en los comentarios y feedback recibidos, efectúa las revisiones necesarias<br>
                en los archivos relevantes. Asegúrate de abordar todos los problemas señalados y seguir las sugerencias de mejora proporcionadas.<br><br>

                <b>4</b>. <b>Realiza un nuevo commit</b>: Después de efectuar las correcciones, utiliza el comando <b>git commit -am '(comentario)'</b> para<br>
                crear un nuevo commit que refleje las correcciones realizadas. Asegúrate de proporcionar<br>
                un mensaje claro y descriptivo para indicar las modificaciones realizadas.<br><br>

                <b>5</b>. <b>Sube los cambios al repositorio remoto</b>: Utiliza el comando <b>git push origin (rama)</b><br>
                para subir los cambios corregidos a la rama correspondiente en el repositorio remoto.<br><br>

                <b>6</b>. <b>Actualiza el pull request</b>: Una vez que los cambios corregidos se hayan subido al repositorio<br>
                remoto, el pull request se actualizará automáticamente para reflejar las modificaciones<br>
                procedidas en la rama. Los revisores podrán ver los nuevos cambios y comentarios.<br><br>

                <b>7</b>. <b>Comunica las correcciones realizadas</b>: Si consideras que has abordado adecuadamente los problemas señalados y las<br>
                sugerencias de mejora, puedes comunicar a los revisores que has realizado las correcciones<br>
                necesarias y que el pull request está listo para ser revisado nuevamente.
            </p>
    <h3>Es hora de administrar tus pull requests</h3>
            <p>
                Al seguir estos pasos, podrás revisar un pull request de manera efectiva, asegurándote de abordar los problemas<br>
                identificados y proporcionar una versión mejorada de los cambios propuestos. La comunicación abierta<br>
                y clara con los revisores es fundamental durante este proceso para garantizar una colaboración exitosa.<br><br>

                Recuerda que cualquier modificación que realices en una rama también modificará el pull request, así<br>
                que es importante que procedas con los cambios necesarios y los subas de nuevo al repositorio remoto<br>
                antes de aceptar el pull request.
            </p>

    <h1>Git & GitHub | Class #22</h1>

    <h2>Creando un Fork, contribuyendo a un repositorio</h2>
            <p>
                Los <b>forks o bifurcaciones</b> son una característica única de GitHub en la que se crea una copia<br>
                exacta del estado actual de un repositorio directamente en GitHub. Este repositorio podrá servir<br>
                como otro origen y se podrá clonar (como cualquier otro repositorio). En pocas palabras, lo podremos<br>
                utilizar como un nuevo repositorio git cualquiera.<br><br>

                Un fork es como una bifurcación del repositorio completo. Comparte una historia en común con el<br>
                original, pero de repente se bifurca y pueden aparecer varios cambios, ya que ambos proyectos podrán<br>
                ser modificados en paralelo y para estar al día un colaborador tendrá que estar actualizando su fork con la información del original.<br><br>

                Al hacer un fork de un poryecto en GitHub, te conviertes en dueñ@ del repositorio fork, puedes trabajar en este con todos los permisos, pero<br>
                es un repositorio completamente diferente que el original, teniendo solamente alguna historia en<br>
                común (como crédito al creado o creadora original).<br><br>

                Los forks son importantes porque es la manera en la que funciona el open source, ya que, una persona puede no<br>
                ser colaborador de un proyecto, pero puede contribuír al mismo, haciendo mejor software que pueda ser utilizado por cualquiera.
            </p>

    <h3>Cómo se hace un fork remoto desde consola en GitHub</h3>
            <p>
                Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite<br>
                al colaborador hacer pull request desde su repositorio propio.<br><br>

                Cuando trabajas en un proyecto que existe en diferentes repositorios remotos (normalmente a causa de un fork), es<br>
                muy probable que desees poder trabajar con ambos repositorios. Para esto, puedes generar un remoto adicional desde consola.
            </p>

            <ul>
                <li> <b>git remote add (nombre_del_remoto) (url_del_remoto)</b> </li>
                <li> <b>git remote upstream (url_del_repositorio)</b> </li>
            </ul>

            <p>
                Al crear un remoto adicional, podremos hacer pull desde el nuevo origen. En caso de tener<br>
                permisos, podremos hacer fetch y push.
            </p>

            <ul>
                <li> <b>git pull (remoto) (rama)</b> </li>
                <li> <b>git pull upstream master</b> </li>
            </ul>

            <p>
                Este pull nos traerá los cambios del remoto, por lo que se estará al día en el proyecto. El<br>
                flujo de trabajo cambia, en adelante se estará trabajando haciendo pull desde el upstream y push<br>
                al origin para pasar a hacer pull request.
            </p>

            <ul>
                <li> <b>git pull upstream master</b> </li>
                <li> <b>git push origin master</b> </li>
            </ul>

    <h1>Git & GitHub | Class #23</h1>

    <h2>Haciendo deployment a un servidor</h2>
            <p>
                Deploy es el proceso que permite enviar al servidor uno o varios archivos. Este<br>
                servidor puede ser de prueba, desarrollo o producción.<br><br>
                
                En el siguiente ejemplo veremos cómo se realiza el deployment de un documento en un servidor web básico.
            </p>
    
    <h3>Pasos para hacer deployment en un servidor web:</h3>
            <ul>
                <li>Entrar a la capeta de los archivos del servidor.</li>
                <li>Copiar link en clone, elegir entre HTTPS o SSH del repositorio a contribuir.<br>
                    -En la carpeta deseada se clona el repositorio: <br><br> 
                <b>git clone url</b><br>
                <b>Deploy:</b>
                </li> <br>

                <li>Realizar cambios y commit en GitHub.</li>
                <li>Traer al Repositorio local las actualizacion para el servidor en la capeta de los archivos del servidor. <br><br>
                <b>git pull ramaRemota main</b></li>
            </ul>

            <p>
                Nota: Siempre se debe proteger el archivo .git. Dependiendo del software para el servidor web, existen diferentes<br>
                maneras. La conexión entre GitHub y el servidor se puede realizar mediante: Travis (pago) o Jenkis (Open source).
            </p>

    <h1>Git & GitHub | Class #24</h1>

    <h2>Ignorar archivos en el repositorio con .gitignore</h2>
            <p>
                No todos los archivos que agregas a un proyecto deberían ir a un repositorio. Por<br>
                ejemplo, cuando tienes un archivo donde están tus contraseñas que comúnmente tienen la extensión<br>
                <b>.env</b> o cuando te estás conectando a una base de datos; <b>son archivos que nadie debe ver</b>.<br><br>

                Por diversas razones, no todos los archivos que agregas a un proyecto deberían guardarse en un<br>
                repositorio. Esto es porque hay archivos que no todo el mundo debería de ver, y hay archivos que al<br>
                estar en el repositorio ralentizan el proceso de desarrollo (por ejemplo: los binary large objects, blob, que<br>
                tardan en descargarse).<br><br>

                Para que no se suban estos archivos no deseados se puede crear un archivo con el nombre .gitignore en<br>
                la raíz del repositorio con las reglas para los archivos que no se deberían subir: Aquí puedes ver la<br>
                sintaxis de los .gitignore.<br><br>

                Las razones principales para tomar la decisión de no agregar un archivo a un repositorio son:
            </p>

            <ul>
                <li>Es un archivo con contraseñas (normalmente con la extensión <b>.env</b>)</li>
                <li>Es un <b>blob</b> (binary large object, objeto binario grande), mismos que son difíciles de gestionar en git.</li>
                <li>Son archivos que se generan corriendo comandos, por ejemplo la carpeta <b>node_modules</b>, que genera <b>npm</b> al correr el comando npm install</li>
            </ul>

    <h1>Git & GitHub | Class #25</h1>

    <h2>Readme.md es una excelente práctica</h2>
            <p>
                <b>README.md</b> es el lugar donde se explica de qué trata el proyecto, cómo utilizarlo y demás información que se considere que se<br>
                deba conocer cualquier persona que vaya a trabajar de alguna forma con el proyecto.<br><br>

                Los archivos README son escritos en un lenguaje llamado <b>markdown</b>, por eso la extensión .md, mismo<br>
                que es un estándar de escritura en diversos sitios (como Platzi, Wikipedia y el mismo<br>
                GitHub).<br><br>

                Los <b>README.md</b> pueden estar en todas las carpetas, pero el más importante es el que se encuentra<br>
                en la raíz. Este documento ayuda a que los colaboradores sepan información relevante del proyecto, módulo<br>
                o sección. Puedes crear cualquier archivo con la extensión .md pero solo los <b>README.md</b> los mostrará por defecto GitHub.
           </p>
</body>
</html>