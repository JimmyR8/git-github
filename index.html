<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git | GitHub</title>
</head>
<body>
    <h1>Git & GitHub | Class #1</h1>
        <p>
            Git es un sistema de control de versiones distribuido que te permite registrar los<br/> 
            cambios que haces en tus archivos y volver a versiones anteriores si algo sale mal.<br/>
            Fue diseñado por Linus Torvalds para garantizar la eficiencia y confiabilidad del<br/>
            mantenimiento de versiones de aplicaciones que tienen un gran número de archivos de código fuente.
        </p>

        <ul>
            <li>Git está optimizado para guardar cambios de forma incremental.</li>
            <li>Permite contar con un historial, regresar a una versión anterior y agregar funcionalidades.</li>
            <li>Lleva un registro de los cambios que otras personas realicen en los archivos.
        </ul>
            
        <p>
           Git fue diseñado para operar en un entorno Linux. Actualmente, es multiplataforma, es decir, es compatible con Linux, MacOS y<br/>
           Windows. En la máquina local se encuentra Git, se utiliza bajo la terminal o línea de comandos y tiene comandos como merge,<br/>  
           pull, add, commit y rebase, entre otros.
        </p>

    <h3>Para qué proyectos sirve Git</h3>
        <p>
            Con Git se obtiene una mayor eficiencia usando archivos de texto plano, ya que con<br/> 
             archivos binarios no puede guardar solo los cambios, sino que debe volver a grabar<br/> 
            el archivo completo ante cada modificación, por mínima que sea, lo que hace que<br/>  
            incremente demasiado el tamaño del repositorio.
        </p>

    <h3>Características de Git</h3>
        <p>
            Git te ayuda a trabajar de manera más organizada y colaborativa en proyectos de desarrollo de software.<br/>
            Estas son algunas de sus principales características:
        </p>

    <h3>Control de versiones</h3>
        <p>
            Git almacena la información como un conjunto de archivos. Te permite llevar un<br/>
            registro de los cambios que haces en tus archivos, lo que significa que siempre<br/>
            puedes volver a versiones anteriores si algo sale mal.
        </p>

    <h3>Ramificación</h3>
        <p>
            Puedes crear ramas en tu proyecto, lo que te permite trabajar en diferentes<br/>
           características o aspectos del mismo sin afectar el trabajo de los demás.
        </p>

    <h3>Colaboración</h3>
        <p>
            En Git, varias personas pueden trabajar en diferentes aspectos del proyecto al<br/>
            mismo tiempo.
        </p>

    <h3>Seguridad</h3>
        <p>
            No existen cambios, corrupción en archivos o cualquier alteración sin que Git lo<br/>
            sepa. Git cuenta con 3 estados en los que es posible localizar archivos: Staged,<br/>
            Modified y Committed.
        </p>

    <h3>Flexibilidad</h3>
        <p>
            Casi todo en Git es local. Es difícil que se necesiten recursos o información<br/>
            externos, basta con los recursos locales con los que cuenta.
        </p>

    <h3>Comandos</h3>
        <p>
            Git tiene una sintaxis de comandos bastante sencilla y fácil de aprender, lo que lo<br/>
            hace accesible incluso para principiantes en programación.
        </p>

    <h3>¿Qué es un sistema de control de versiones?</h3>
        <p>
            El SCV o VCS (por sus siglas en inglés) es un sistema que registra los cambios<br/>
            realizados sobre un archivo o conjunto de archivos a lo largo del tiempo, de modo<br/>
            que puedas llevar el historial del ciclo de vida de un proyecto, comparar cambios a<br/>
            lo largo del tiempo, ver quién los realizó o revertir el proyecto entero a un estado<br/>
            anterior.
        </p>

    <h3>Características de Github</h3>
        <ul>
            <li>GitHub permite alojar proyectos en repositorios de forma gratuita y pública, pero tiene una forma de pago para privados.</li>
            <li>Puedes compartir fácilmente tus proyectos.</li>
            <li>Permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos.</li>
            <li>Ayuda a reducir significativamente los errores humanos, a tener un mejor mantenimiento de distintos entornos y a detectar fallos de una forma más rápida y eficiente.</li>
            <li>Es la opción perfecta para poder trabajar en equipo en un mismo proyecto.</li>
            <li>Ofrece todas las ventajas del sistema de control de versiones Git, pero también tiene otras herramientas que ayudan a tener un mejor control de los proyectos.</li>
         </ul>

    <h1>Git & GitHub | Class #2</h1>
    
    <h2>Editores de código, archivos binarios y de texto plano</h2>
        <p>
            Un editor de código o IDE es una herramienta que nos brinda muchas ayudas para escribir código, algo así como un bloc de<br>
            muy avanzado. Los editores más populares son
        </p>

        <ul>
            <li>Atom</li>
            <li>Sublime</li>
            <li>Visual Studio code (es el mas popular y usado)</li>
        </ul>
    
    <h3>Tipos de archivos y sus diferencias:</h3>
        <ul>
            <li>Archivos de Texto (<b>.txt</b>): Texto plano normal y sin nada especial. Lo vemos igual<br>
                sin importar dónde lo abramos, ya sea con el bloc de notas o con editores<br>
                de texto avanzados.
            </li><br>
            
            <li>Archivos RTF (<b>.rtf</b>): Podemos guardar texto con diferentes tamaños, estilos y<br>
                colores. Pero si lo abrimos desde un editor de código, vamos a ver que es<br>
                mucho más complejo que solo el texto plano. Esto es porque debe guardar<br>
                todos los estilos del texto y, para esto, usa un código especial un poco difícil de<br>
                entender y muy diferente a los textos con estilos especiales al que estamos<br>
                acostumbrados.
            </li><br>
            
            <li>Archivos de Word (<b>.docx</b>): Podemos guardar imágenes y texto con diferentes<br>
                tamaños, estilos o colores. Al abrirlo desde un editor de código podemos ver<br>
                que es código binario, muy difícil de entender y muy diferente al texto al que<br>
                estamos acostumbrados. Esto es porque Word está optimizado para entender<br>
                este código especial y representarlo gráficamente.
            </li>    
        </ul>

        <p>
            Debemos recordar habilitar la opción de ver la extensión de los archivos, de lo contrario, solo podremos ver su nombre.<br>
            La forma de hacerlo en Windows es <b>Vista > Mostrar u ocultar > Extensiones de nombre de archivo</b>.
        </p>

    <h3>Conceptos importantes de Git</h3>
        <ul>
            <li> <b>Bug</b>: Error en el código</li><br>

            <li> <b>Repository</b>: Donde se almacena todo el proyecto, el cual puede vivir tanto en local como en<br>
                remoto. El repositorio guarda un historial de versiones y, más<br>
                importante, de la relación de cada versión con la anterior para que pueda<br> 
                hacerse el árbol de versiones con las diferentes ramas.
            </li><br>

            <li> <b>Clone</b>: Una vez se decide hacer un fork , hasta ese momento sólo existe en<br>
                GitHub. Para poder trabajar en el proyecto, toca clonar el repositorio elegido al<br>
                computador personal.
            </li><br>

            <li> <b>Branch</b>: Es una bifurcación del proyecto que se está realizando para anexar una<br>
                nueva funcionalidad o corregir un bug.
            </li><br>

            <li> <b>Master</b>: Rama donde se almacena la última versión estable del proyecto que se<br>
                está realizando. La rama master es la que está en producción en cada momento<br>
                (o casi) y debería estar libre de bugs. Así, si esta rama está en producción, sirve<br>
                como referente para hacer nuevas funcionalidades y/o arreglar bugs de última hora.
            </li><br>

            <li> <b>Commit</b>: consiste en subir cosas a la versión local del repositorio. De esta<br>
                manera se puede trabajar en la rama de forma local sin tener que modificar<br>
                ninguna versión en remoto ni tener que tener la última versión remota, cosa<br>
                muy útil en grandes desarrollos trabajados por varias personas.
            </li><br>

            <li> <b>Push</b>: Consiste en enviar todo lo que se ha confirmado con un commit al<br>
                repositorio remoto. Aquí es donde se une nuestro trabajo con el de los demás.
            </li><br>

            <li> <b>Checkout</b>: Acción de descargarse una rama del repositorio GIT local (sí, GIT<br>
                tiene su propio repositorio en local para poder ir haciendo commits) o remoto.
            </li><br>

            <li> <b>Fetch</b>: Actualiza el repositorio local bajando datos del repositorio remoto al<br>
                repositorio local sin actualizarlo, es decir, se guarda una copia del repositorio<br>
                remoto en el local.
            </li><br>
                
            <li> <b>Merge</b>: La acción de merge es la continuación natural del fetch. El merge<br>
                permite unir la copia del repositorio remoto con tu repositorio local, mezclando<br>
                los diferentes códigos.
            </li><br>

            <li> <b>Pull</b>: Consiste en la unión del fetch y del merge, esto es, recoge la información<br>
                del repositorio remoto y luego mezcla el trabajo en local con esta.
            </li><br>

            <li> <b>Diff</b>: Se utiliza para mostrar los cambios entre dos versiones del mismo archivo.</li><br>
        </ul>

    <h1>Git & GitHub | Class #3</h1>
        <ul>
            <li>Para inicializar el repositorio git y el staged: <b>git init</b> </li>
            <li>Enviar el archivo al staged: <b>git add nombre_del_archivo.txt</b> </li>
            <li>Ver el estado, si se requiere agregar al starget o si se requiere commit: <b>git status</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf --list</b> </li>
            <li>Para mostrar las configuraciones y sus rutas: <b>para mostrar las configuraciones y sus rutas</b> </li>
            <li>Para eliminar el archivo del staged(ram): <b>git rm --cached nombre_del_archivo.txt</b> </li>
            <li>Para eliminar del repositorio: <b>para eliminar del repositorio</b> </li>
        </ul>

        <p>
            Recuerda que Git está optimizado para trabajar en equipo, por lo tanto, debemos<br>
            darle un poco de información sobre nosotros. No debemos hacerlo todas las veces<br>
            que ejecutamos un comando, basta con ejecutar solo una sola vez los siguientes<br>
            comandos con tu información:
        </p>

        <ul>
            <li>git config --global user.email "tu@email.com"</li>
            <li>git config --global user.name "Tu Nombre"</li>
         </ul>

         <p>
            Si por algún motivo te equivocaste en el nombre o email que configuraste al principio, lo puedes modificar de la siguiente manera:
         </p>

         <ul>
            <li>git config --global --replace-all user.name “Aquí va tu nombre modificado”</li>
         </ul>

         <p>
            O si lo deseas eliminar y añadir uno nuevo
        </p>

        <ul>
            <li>git config --global --unset-all user.name :Elimina el nombre del usuario</li>
            <li>git config --global --add user.name “Aquí va tu nombre”</li>
        </ul>

    <h1>Git & GitHub | Class #4</h1>
        <h2>Analizar cambios en los archivos de tu proyecto con Git</h2>
        <ul>
            <li>Mostrar cambios que exiten en un archivo: <b>git show</b> </li>
            <li>Guardar cambios de un archivo: <b>git add .</b> </li>
            <li>Agregamos los cambios para el repositorio: <b>git commit -m “Mensaje”</b> </li>
            <li>Histórico de cambios con detalles: <b>git log nombre_de_archivos.extensión</b> </li>
            <li>Envía a otro repositorio remoto lo que estamos haciendo: <b>git push</b> </li>
            <li>Ver diferencias de un commit a otro commit: <b>git diff (identificador-de-commit) (identificador-de-commit)</b></li>
        </ul>

    <h1>Git & GitHub | Class #5</h1>

    <h2>¿Qué es el staging?</h2>
        <p>
            El staging es el lugar donde se guardan temporalmente los cambios, para luego ser<br>
            llevados definitivamente al repositorio. El repositorio es el lugar donde se guardan<br>
            todos los registros de los cambios realizados a los archivos.
        </p>

    <h3>¿Qué es el área de staging?</h3>
        <p>
            El área de staging se puede ver como un limbo donde nuestros archivos están por ser<br>
            enviados al repositorio o ser regresados a la carpeta del proyecto.
        </p>

    <h3>Cómo funciona el staging y el repositorio: ciclo básico de trabajo en git:</h3>
        <ul>
            <p>
                El flujo de trabajo básico en git es algo así:
            </p>

            <li>Modificas una serie de archivos en tu directorio de trabajo.</li>
            <li>Preparas los archivos, añadiéndolos a tu área de preparación (staging).</li>
            <li>Confirmas los cambios (commit), lo que toma los archivos tal y como están en el área de preparación y almacena 
                esa copia instantánea de manera permanente en tu directorio de git.</li>
        </ul>

        <p>Veamos a detalle las 3 secciones principales que tiene un proyecto en git.</p>

    <h3> <u>Working directory</u></h3>
        <p>
            El working directory es una copia de una versión del proyecto. Estos archivos se sacan<br>
            de la base de datos comprimida en el directorio de git y se colocan en el disco para<br>
            que los puedas usar o modificar.
        </p>

    <h3> <u>Staging area</u></h3>
        <p>
            Es un área que almacena información acerca de lo que va a ir en tu próxima confirmación. A veces se le denomina índice (index).
        </p>

    <h3> <u>.git directory (repository)</u></h3>
        <p>
            En el repository se almacenan los metadatos y la base de datos de los objetos para tu<br>
            proyecto. Es la parte más importante de git (carpeta .git) y es lo que se copia cuando<br>
            clonas un repositorio desde otra computadora.
        </p>

    <h3>Ciclo de vida o estados de los archivos en git</h3>
        <p>
            Cuando trabajamos con git, nuestros archivos pueden vivir y moverse entre 4<br>
            diferentes estados (cuando trabajamos con repositorios remotos pueden ser más<br>
            estados):
        </p>

    <h3> <u>Archivos tracked</u></h3>
        <p>
            Son los archivos que viven dentro de git, no tienen cambios pendientes y sus últimas<br>
            actualizaciones han sido guardadas en el repositorio gracias a los comandos <b>git add</b> y <b>git commit</b>.
        </p>

    <h3> <u>Archivos staged</u></h3>
        <p>
            Son archivos en staging. Viven dentro de git y hay registro de ellos porque han sido<br>
            afectados por el comando <b>git add</b>, aunque no sus últimos cambios. Git ya sabe de la<br>
            existencia de estos últimos cambios, pero todavía no han sido guardados definitivamente en<br>
            el repositorio porque falta ejecutar el comando <b>git commit</b>.
        </p>

    <h3> <u>Archivos unstaged</u></h3>
        <p>
            Entiéndelos como archivos “tracked pero unstaged”. Son archivos que viven dentro<br>
            de git pero no han sido afectados por el comando <b>git add</b> ni mucho menos por <b>git commit</b>.<br>
            Git tiene un registro de estos archivos, pero está desactualizado, sus últimas<br>
            versiones solo están guardadas en el disco duro.
        </p>

    <h3> <u>Archivos untracked</u></h3>
        <p>
            Son archivos que NO viven dentro de git, solo en el disco duro. Nunca han sido<br>
            afectados por <b>git add</b>, así que git no tiene registros de su existencia.
        </p>
        <p>
            Recordar que hay un caso muy raro donde los archivos tienen dos estados al mismo<br>
            tiempo: staged y untracked. Esto pasa cuando guardamos los cambios de un archivo en<br>
            el área de staging (con el comando <b>git add</b>), pero antes de hacer commit para<br>
            guardar los cambios en el repositorio haces nuevos cambios que todavía no han sido<br>
            guardados en el área de staging.
        </p>

    <h1>Git & GitHub | Class #6</h1>

    <h2>¿Qué es branch (rama) y cómo funciona un Merge en Git?</h2>
    
        <p>
            Una <b>rama</b> o <b>branch</b> es una versión del código del proyecto sobre el que estás trabajando. Estas<br>
            ramas ayudan a mantener el orden en el control de versiones y manipular el código de forma segura.<br>
        </p>

    <h3>Clases de branches o ramas en Git</h3>
        <p>
            Estas son las ramas base de un proyecto en Git:
        </p>

    <h3> <u>1. Rama main (Master)</u> </h3>
        <p>
            Por defecto, el proyecto se crea en una rama llamada Main (anteriormente conocida como Master).<br>
            Cada vez que añades código y guardas los cambios, estás haciendo un commit, que es añadir el nuevo<br>
            código a una rama. Esto genera nuevas versiones de esta rama o branch, hasta llegar a la versión actual de la rama Main.
        </p>
    
    <h3> <u>2. Rama development</u> </h3>
        <p>
            Cuando decides hacer experimentos, puedes generar ramas experimentales<br>
            (usualmente llamadas development), que están basadas en alguna rama main, pero<br>
            sobre las cuales puedes hacer cambios a tu gusto sin necesidad de afectar directamente al código principal.
        </p>

    <h3> <u>3. Rama hotfix</u> </h3>
        <p>
            En otros casos, si encuentras un bug o error de código en la rama Main (que afecta al<br>
            proyecto en producción), tendrás que crear una nueva rama (que usualmente se<br>
            llaman bug fixing o hot fix) para hacer los arreglos necesarios. Cuando los cambios<br>
            estén listos, los tendrás que fusionar con la rama Main para que los cambios sean<br>
            aplicados. Para esto, se usa un comando llamado <b>Merge</b>, que mezcla los cambios de<br>
            la rama que originaste a la rama <b>Main</b>.
        </p>
        <p>
            <b>Todos los commits se aplican sobre una rama</b>. Por defecto, siempre empezamos en<br>
            la rama Main (pero puedes cambiarle el nombre si no te gusta) y generamos nuevas<br>
            ramas, a partir de esta, para crear flujos de trabajo independientes.
        </p>

    <h1>Git & GitHub | Class #7</h1>

    <h2>Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h2>
        <ul>
            <li>Nos muestra el historial de commits hechos de el mas reciente hasta el mas viejo: <b>git log</b> </li>
            <li>Nos muestra el historial de cambios especificos de cada commit desde el mas reciete hasta el mas viejo: <b>git log --stat</b> </li>
            <li>Muestra los cambios hechos al archivo en el ultimo commit: <b>git show (nombre_del_archivo)</b> </li>
            <li>Nos muestra las diferencias entres los cambios que estan en Staging y los que aun no se han añadido: <b>git diff</b> </li>
            <li>Nos muestra las diferencias entre las dos versiones de los commits: <b>git diff (id-del-commit) (id-del-commit)</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, pero sin borrar los commits usados anteriormente: <b>git reset (id-del-commit) --soft</b> </li>
            <li>Volvemos nuestro archivo a la version del commit indicada, BORRANDO TODOS los commits usados anteriores a la version del commit indicada: <b>git reset (id-del-commit) --hard</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, sin cambiar nada en el Staging: <b>git checkout (id-del-commit) (nombre_del_archivo)</b> </li>
            <li>Volvemos a nuestro archivo a la version que teniamos antes de hacer el primer checkout, sin cambiar nada en el Staging: <b>git checkout master (nombre_del_archivo)</b> </li>
        </ul>
</body>
</html>