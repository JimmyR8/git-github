<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git | GitHub</title>
</head>
<body>
    <h1>Git & GitHub | Class #1</h1>
        <p>
            Git es un sistema de control de versiones distribuido que te permite registrar los<br/> 
            cambios que haces en tus archivos y volver a versiones anteriores si algo sale mal.<br/>
            Fue diseñado por Linus Torvalds para garantizar la eficiencia y confiabilidad del<br/>
            mantenimiento de versiones de aplicaciones que tienen un gran número de archivos de código fuente.
        </p>

        <ul>
            <li>Git está optimizado para guardar cambios de forma incremental.</li>
            <li>Permite contar con un historial, regresar a una versión anterior y agregar funcionalidades.</li>
            <li>Lleva un registro de los cambios que otras personas realicen en los archivos.
        </ul>
            
        <p>
           Git fue diseñado para operar en un entorno Linux. Actualmente, es multiplataforma, es decir, es compatible con Linux, MacOS y<br/>
           Windows. En la máquina local se encuentra Git, se utiliza bajo la terminal o línea de comandos y tiene comandos como merge,<br/>  
           pull, add, commit y rebase, entre otros.
        </p>

    <h3>Para qué proyectos sirve Git</h3>
        <p>
            Con Git se obtiene una mayor eficiencia usando archivos de texto plano, ya que con<br/> 
             archivos binarios no puede guardar solo los cambios, sino que debe volver a grabar<br/> 
            el archivo completo ante cada modificación, por mínima que sea, lo que hace que<br/>  
            incremente demasiado el tamaño del repositorio.
        </p>

    <h3>Características de Git</h3>
        <p>
            Git te ayuda a trabajar de manera más organizada y colaborativa en proyectos de desarrollo de software.<br/>
            Estas son algunas de sus principales características:
        </p>

    <h3>Control de versiones</h3>
        <p>
            Git almacena la información como un conjunto de archivos. Te permite llevar un<br/>
            registro de los cambios que haces en tus archivos, lo que significa que siempre<br/>
            puedes volver a versiones anteriores si algo sale mal.
        </p>

    <h3>Ramificación</h3>
        <p>
            Puedes crear ramas en tu proyecto, lo que te permite trabajar en diferentes<br/>
           características o aspectos del mismo sin afectar el trabajo de los demás.
        </p>

    <h3>Colaboración</h3>
        <p>
            En Git, varias personas pueden trabajar en diferentes aspectos del proyecto al<br/>
            mismo tiempo.
        </p>

    <h3>Seguridad</h3>
        <p>
            No existen cambios, corrupción en archivos o cualquier alteración sin que Git lo<br/>
            sepa. Git cuenta con 3 estados en los que es posible localizar archivos: Staged,<br/>
            Modified y Committed.
        </p>

    <h3>Flexibilidad</h3>
        <p>
            Casi todo en Git es local. Es difícil que se necesiten recursos o información<br/>
            externos, basta con los recursos locales con los que cuenta.
        </p>

    <h3>Comandos</h3>
        <p>
            Git tiene una sintaxis de comandos bastante sencilla y fácil de aprender, lo que lo<br/>
            hace accesible incluso para principiantes en programación.
        </p>

    <h3>¿Qué es un sistema de control de versiones?</h3>
        <p>
            El SCV o VCS (por sus siglas en inglés) es un sistema que registra los cambios<br/>
            realizados sobre un archivo o conjunto de archivos a lo largo del tiempo, de modo<br/>
            que puedas llevar el historial del ciclo de vida de un proyecto, comparar cambios a<br/>
            lo largo del tiempo, ver quién los realizó o revertir el proyecto entero a un estado<br/>
            anterior.
        </p>

    <h3>Características de Github</h3>
        <ul>
            <li>GitHub permite alojar proyectos en repositorios de forma gratuita y pública, pero tiene una forma de pago para privados.</li>
            <li>Puedes compartir fácilmente tus proyectos.</li>
            <li>Permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos.</li>
            <li>Ayuda a reducir significativamente los errores humanos, a tener un mejor mantenimiento de distintos entornos y a detectar fallos de una forma más rápida y eficiente.</li>
            <li>Es la opción perfecta para poder trabajar en equipo en un mismo proyecto.</li>
            <li>Ofrece todas las ventajas del sistema de control de versiones Git, pero también tiene otras herramientas que ayudan a tener un mejor control de los proyectos.</li>
         </ul>

    <h1>Git & GitHub | Class #2</h1>
    
    <h2>Editores de código, archivos binarios y de texto plano</h2>
        <p>
            Un editor de código o IDE es una herramienta que nos brinda muchas ayudas para escribir código, algo así como un bloc de<br>
            muy avanzado. Los editores más populares son
        </p>

        <ul>
            <li>Atom</li>
            <li>Sublime</li>
            <li>Visual Studio code (es el mas popular y usado)</li>
        </ul>
    
    <h3>Tipos de archivos y sus diferencias:</h3>
        <ul>
            <li>Archivos de Texto (<b>.txt</b>): Texto plano normal y sin nada especial. Lo vemos igual<br>
                sin importar dónde lo abramos, ya sea con el bloc de notas o con editores<br>
                de texto avanzados.
            </li><br>
            
            <li>Archivos RTF (<b>.rtf</b>): Podemos guardar texto con diferentes tamaños, estilos y<br>
                colores. Pero si lo abrimos desde un editor de código, vamos a ver que es<br>
                mucho más complejo que solo el texto plano. Esto es porque debe guardar<br>
                todos los estilos del texto y, para esto, usa un código especial un poco difícil de<br>
                entender y muy diferente a los textos con estilos especiales al que estamos<br>
                acostumbrados.
            </li><br>
            
            <li>Archivos de Word (<b>.docx</b>): Podemos guardar imágenes y texto con diferentes<br>
                tamaños, estilos o colores. Al abrirlo desde un editor de código podemos ver<br>
                que es código binario, muy difícil de entender y muy diferente al texto al que<br>
                estamos acostumbrados. Esto es porque Word está optimizado para entender<br>
                este código especial y representarlo gráficamente.
            </li>    
        </ul>

        <p>
            Debemos recordar habilitar la opción de ver la extensión de los archivos, de lo contrario, solo podremos ver su nombre.<br>
            La forma de hacerlo en Windows es <b>Vista > Mostrar u ocultar > Extensiones de nombre de archivo</b>.
        </p>

    <h3>Conceptos importantes de Git</h3>
        <ul>
            <li> <b>Bug</b>: Error en el código</li><br>

            <li> <b>Repository</b>: Donde se almacena todo el proyecto, el cual puede vivir tanto en local como en<br>
                remoto. El repositorio guarda un historial de versiones y, más<br>
                importante, de la relación de cada versión con la anterior para que pueda<br> 
                hacerse el árbol de versiones con las diferentes ramas.
            </li><br>

            <li> <b>Clone</b>: Una vez se decide hacer un fork , hasta ese momento sólo existe en<br>
                GitHub. Para poder trabajar en el proyecto, toca clonar el repositorio elegido al<br>
                computador personal.
            </li><br>

            <li> <b>Branch</b>: Es una bifurcación del proyecto que se está realizando para anexar una<br>
                nueva funcionalidad o corregir un bug.
            </li><br>

            <li> <b>Master</b>: Rama donde se almacena la última versión estable del proyecto que se<br>
                está realizando. La rama master es la que está en producción en cada momento<br>
                (o casi) y debería estar libre de bugs. Así, si esta rama está en producción, sirve<br>
                como referente para hacer nuevas funcionalidades y/o arreglar bugs de última hora.
            </li><br>

            <li> <b>Commit</b>: consiste en subir cosas a la versión local del repositorio. De esta<br>
                manera se puede trabajar en la rama de forma local sin tener que modificar<br>
                ninguna versión en remoto ni tener que tener la última versión remota, cosa<br>
                muy útil en grandes desarrollos trabajados por varias personas.
            </li><br>

            <li> <b>Push</b>: Consiste en enviar todo lo que se ha confirmado con un commit al<br>
                repositorio remoto. Aquí es donde se une nuestro trabajo con el de los demás.
            </li><br>

            <li> <b>Checkout</b>: Acción de descargarse una rama del repositorio GIT local (sí, GIT<br>
                tiene su propio repositorio en local para poder ir haciendo commits) o remoto.
            </li><br>

            <li> <b>Fetch</b>: Actualiza el repositorio local bajando datos del repositorio remoto al<br>
                repositorio local sin actualizarlo, es decir, se guarda una copia del repositorio<br>
                remoto en el local.
            </li><br>
                
            <li> <b>Merge</b>: La acción de merge es la continuación natural del fetch. El merge<br>
                permite unir la copia del repositorio remoto con tu repositorio local, mezclando<br>
                los diferentes códigos.
            </li><br>

            <li> <b>Pull</b>: Consiste en la unión del fetch y del merge, esto es, recoge la información<br>
                del repositorio remoto y luego mezcla el trabajo en local con esta.
            </li><br>

            <li> <b>Diff</b>: Se utiliza para mostrar los cambios entre dos versiones del mismo archivo.</li><br>
        </ul>

    <h1>Git & GitHub | Class #3</h1>
        <ul>
            <li>Para inicializar el repositorio git y el staged: <b>git init</b> </li>
            <li>Enviar el archivo al staged: <b>git add nombre_del_archivo.txt</b> </li>
            <li>Ver el estado, si se requiere agregar al starget o si se requiere commit: <b>git status</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf</b> </li>
            <li>Para ver las posibles configuraciones: <b>git conf --list</b> </li>
            <li>Para mostrar las configuraciones y sus rutas: <b>para mostrar las configuraciones y sus rutas</b> </li>
            <li>Para eliminar el archivo del staged(ram): <b>git rm --cached nombre_del_archivo.txt</b> </li>
            <li>Para eliminar del repositorio: <b>para eliminar del repositorio</b> </li>
        </ul>

        <p>
            Recuerda que Git está optimizado para trabajar en equipo, por lo tanto, debemos<br>
            darle un poco de información sobre nosotros. No debemos hacerlo todas las veces<br>
            que ejecutamos un comando, basta con ejecutar solo una sola vez los siguientes<br>
            comandos con tu información:
        </p>

        <ul>
            <li>git config --global user.email "tu@email.com"</li>
            <li>git config --global user.name "Tu Nombre"</li>
         </ul>

         <p>
            Si por algún motivo te equivocaste en el nombre o email que configuraste al principio, lo puedes modificar de la siguiente manera:
         </p>

         <ul>
            <li>git config --global --replace-all user.name “Aquí va tu nombre modificado”</li>
         </ul>

         <p>
            O si lo deseas eliminar y añadir uno nuevo
        </p>

        <ul>
            <li>git config --global --unset-all user.name :Elimina el nombre del usuario</li>
            <li>git config --global --add user.name “Aquí va tu nombre”</li>
        </ul>

    <h1>Git & GitHub | Class #4</h1>
        <h2>Analizar cambios en los archivos de tu proyecto con Git</h2>
        <ul>
            <li>Mostrar cambios que exiten en un archivo: <b>git show</b> </li>
            <li>Guardar cambios de un archivo: <b>git add .</b> </li>
            <li>Agregamos los cambios para el repositorio: <b>git commit -m “Mensaje”</b> </li>
            <li>Histórico de cambios con detalles: <b>git log nombre_de_archivos.extensión</b> </li>
            <li>Envía a otro repositorio remoto lo que estamos haciendo: <b>git push</b> </li>
            <li>Ver diferencias de un commit a otro commit: <b>git diff (identificador-de-commit) (identificador-de-commit)</b></li>
        </ul>

    <h1>Git & GitHub | Class #5</h1>

    <h2>¿Qué es el staging?</h2>
        <p>
            El staging es el lugar donde se guardan temporalmente los cambios, para luego ser<br>
            llevados definitivamente al repositorio. El repositorio es el lugar donde se guardan<br>
            todos los registros de los cambios realizados a los archivos.
        </p>

    <h3>¿Qué es el área de staging?</h3>
        <p>
            El área de staging se puede ver como un limbo donde nuestros archivos están por ser<br>
            enviados al repositorio o ser regresados a la carpeta del proyecto.
        </p>

    <h3>Cómo funciona el staging y el repositorio: ciclo básico de trabajo en git:</h3>
        <ul>
            <p>
                El flujo de trabajo básico en git es algo así:
            </p>

            <li>Modificas una serie de archivos en tu directorio de trabajo.</li>
            <li>Preparas los archivos, añadiéndolos a tu área de preparación (staging).</li>
            <li>Confirmas los cambios (commit), lo que toma los archivos tal y como están en el área de preparación y almacena 
                esa copia instantánea de manera permanente en tu directorio de git.</li>
        </ul>

        <p>Veamos a detalle las 3 secciones principales que tiene un proyecto en git.</p>

    <h3> <u>Working directory</u></h3>
        <p>
            El working directory es una copia de una versión del proyecto. Estos archivos se sacan<br>
            de la base de datos comprimida en el directorio de git y se colocan en el disco para<br>
            que los puedas usar o modificar.
        </p>

    <h3> <u>Staging area</u></h3>
        <p>
            Es un área que almacena información acerca de lo que va a ir en tu próxima confirmación. A veces se le denomina índice (index).
        </p>

    <h3> <u>.git directory (repository)</u></h3>
        <p>
            En el repository se almacenan los metadatos y la base de datos de los objetos para tu<br>
            proyecto. Es la parte más importante de git (carpeta .git) y es lo que se copia cuando<br>
            clonas un repositorio desde otra computadora.
        </p>

    <h3>Ciclo de vida o estados de los archivos en git</h3>
        <p>
            Cuando trabajamos con git, nuestros archivos pueden vivir y moverse entre 4<br>
            diferentes estados (cuando trabajamos con repositorios remotos pueden ser más<br>
            estados):
        </p>

    <h3> <u>Archivos tracked</u></h3>
        <p>
            Son los archivos que viven dentro de git, no tienen cambios pendientes y sus últimas<br>
            actualizaciones han sido guardadas en el repositorio gracias a los comandos <b>git add</b> y <b>git commit</b>.
        </p>

    <h3> <u>Archivos staged</u></h3>
        <p>
            Son archivos en staging. Viven dentro de git y hay registro de ellos porque han sido<br>
            afectados por el comando <b>git add</b>, aunque no sus últimos cambios. Git ya sabe de la<br>
            existencia de estos últimos cambios, pero todavía no han sido guardados definitivamente en<br>
            el repositorio porque falta ejecutar el comando <b>git commit</b>.
        </p>

    <h3> <u>Archivos unstaged</u></h3>
        <p>
            Entiéndelos como archivos “tracked pero unstaged”. Son archivos que viven dentro<br>
            de git pero no han sido afectados por el comando <b>git add</b> ni mucho menos por <b>git commit</b>.<br>
            Git tiene un registro de estos archivos, pero está desactualizado, sus últimas<br>
            versiones solo están guardadas en el disco duro.
        </p>

    <h3> <u>Archivos untracked</u></h3>
        <p>
            Son archivos que NO viven dentro de git, solo en el disco duro. Nunca han sido<br>
            afectados por <b>git add</b>, así que git no tiene registros de su existencia.
        </p>
        <p>
            Recordar que hay un caso muy raro donde los archivos tienen dos estados al mismo<br>
            tiempo: staged y untracked. Esto pasa cuando guardamos los cambios de un archivo en<br>
            el área de staging (con el comando <b>git add</b>), pero antes de hacer commit para<br>
            guardar los cambios en el repositorio haces nuevos cambios que todavía no han sido<br>
            guardados en el área de staging.
        </p>

    <h1>Git & GitHub | Class #6</h1>

    <h2>¿Qué es branch (rama) y cómo funciona un Merge en Git?</h2>
    
        <p>
            Una <b>rama</b> o <b>branch</b> es una versión del código del proyecto sobre el que estás trabajando. Estas<br>
            ramas ayudan a mantener el orden en el control de versiones y manipular el código de forma segura.<br>
        </p>

    <h3>Clases de branches o ramas en Git</h3>
        <p>
            Estas son las ramas base de un proyecto en Git:
        </p>

    <h3> <u>1. Rama main (Master)</u> </h3>
        <p>
            Por defecto, el proyecto se crea en una rama llamada Main (anteriormente conocida como Master).<br>
            Cada vez que añades código y guardas los cambios, estás haciendo un commit, que es añadir el nuevo<br>
            código a una rama. Esto genera nuevas versiones de esta rama o branch, hasta llegar a la versión actual de la rama Main.
        </p>
    
    <h3> <u>2. Rama development</u> </h3>
        <p>
            Cuando decides hacer experimentos, puedes generar ramas experimentales<br>
            (usualmente llamadas development), que están basadas en alguna rama main, pero<br>
            sobre las cuales puedes hacer cambios a tu gusto sin necesidad de afectar directamente al código principal.
        </p>

    <h3> <u>3. Rama hotfix</u> </h3>
        <p>
            En otros casos, si encuentras un bug o error de código en la rama Main (que afecta al<br>
            proyecto en producción), tendrás que crear una nueva rama (que usualmente se<br>
            llaman bug fixing o hot fix) para hacer los arreglos necesarios. Cuando los cambios<br>
            estén listos, los tendrás que fusionar con la rama Main para que los cambios sean<br>
            aplicados. Para esto, se usa un comando llamado <b>Merge</b>, que mezcla los cambios de<br>
            la rama que originaste a la rama <b>Main</b>.
        </p>
        <p>
            <b>Todos los commits se aplican sobre una rama</b>. Por defecto, siempre empezamos en<br>
            la rama Main (pero puedes cambiarle el nombre si no te gusta) y generamos nuevas<br>
            ramas, a partir de esta, para crear flujos de trabajo independientes.
        </p>

    <h1>Git & GitHub | Class #7</h1>

    <h2>Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h2>
        <ul>
            <li>Nos muestra el historial de commits hechos de el mas reciente hasta el mas viejo: <b>git log</b> </li>
            <li>Nos muestra el historial de cambios especificos de cada commit desde el mas reciete hasta el mas viejo: <b>git log --stat</b> </li>
            <li>Muestra los cambios hechos al archivo en el ultimo commit: <b>git show (nombre_del_archivo)</b> </li>
            <li>Nos muestra las diferencias entres los cambios que estan en Staging y los que aun no se han añadido: <b>git diff</b> </li>
            <li>Nos muestra las diferencias entre las dos versiones de los commits: <b>git diff (id-del-commit) (id-del-commit)</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, pero sin borrar los commits usados anteriormente: <b>git reset (id-del-commit) --soft</b> </li>
            <li>Volvemos nuestro archivo a la version del commit indicada, BORRANDO TODOS los commits usados anteriores a la version del commit indicada: <b>git reset (id-del-commit) --hard</b> </li>
            <li>Volvemos a nuestro archivo a la version del commit indicada, sin cambiar nada en el Staging: <b>git checkout (id-del-commit) (nombre_del_archivo)</b> </li>
            <li>Volvemos a nuestro archivo a la version que teniamos antes de hacer el primer checkout, sin cambiar nada en el Staging: <b>git checkout master (nombre_del_archivo)</b> </li>
        </ul>

    <h1>Git & GitHub | Class #8</h1>
    
    <h2>Git reset vs. Git rm</h2>
        <p>
            Los comandos git reset y git rm tienen utilidades muy diferentes, pero pueden confundirse fácilmente.
        </p>

    <h3>Git reset</h3>
        <p>
            El comando <b>git reset</b> es una herramienta poderosa que te permite deshacer o<br>
            revertir cambios en tu repositorio de Git. Lo puedes ejecutar de tres maneras<br>
            diferentes, con las líneas de comando <b>--soft</b>, <b>--mixed</b> y  <b>--hard</b>.
        </p>
        <p>
            Pero no como <b>git checkout</b> que nos deja ir, mirar, pasear y volver. Con <b>git reset</b><br>
            volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia<br> 
            y la debemos sobreescribir. No hay vuelta atrás.
        </p>

    <h3>Variaciones de Git Reset</h3>
        <ul>
            <li>Borra el historial y los registros de Git de commits anteriores, pero guarda los cambios en Staging para aplicar las últimas actualizaciones a un nuevo commit: <b>git reset --soft</b> </li>
            <li>Deshace todo, absolutamente todo. Toda la información de los commits y del área de staging se elimina del historial: <b>git reset --hard</b> </li>
            <li>Borra todo, exactamente todo. Toda la información de los commits y del área de staging se elimina del historial.: <b>git reset --mixed</b> </li>
            <li>El comando git reset saca archivos del área de staging sin borrarlos ni realizar otras acciones. Esto impide que los últimos cambios en estos archivos se envíen al último commit. Podemos incluirlos de nuevo en staging con git add si cambiamos de opinión <b>git reset HEAD</b> </li>
        </ul>

    <h3>¿Qué es git reset HEAD?</h3>
        <p>
            git reset HEAD es un comando que te permite revertir los cambios que ya habías<br>
            preparado para subir, y moverlos de vuelta a tu proyecto. Con este comando puedes<br>
            cancelar los cambios que ya habías agregado, para que puedas revisarlos, modificarlos o<br>
            deshacerlos antes de confirmarlos con un commit.
         </p>

    <h3>Git rm</h3>
        <p>
            Por otro lado, git rm es un comando que nos ayuda a eliminar archivos de Git<br>
            sin eliminar su historial del sistema de versiones. Para recuperar el archivo<br>
            eliminado, necesitamos retroceder en la historia del proyecto, recuperar el último commit<br>
            y obtener la última confirmación antes de la eliminación del archivo.
        </p>

    <h3>Variaciones de Git rm</h3>
        <ul>
            <li>Elimina archivos del repositorio local y área de staging, pero los mantiene en el disco duro. Deja de trackear el historial de cambios de estos archivos, lo cual queda en estado untracked: <b>git rm --cached</b> </li>
            <li>Elimina los archivos de Git y del disco duro. Git guarda todo, por lo que podemos recuperar archivos eliminados si es necesario (empleando comandos avanzados): <b>git rm --force</b> </li>    
        </ul>
        
    <h3>¿Cuál es la diferencia entre git rm y git reset Head?</h3>
        <p>
            La diferencia principal entre git rm y git reset HEAD radica en que git rm<br>
            elimina archivos del repositorio y de la historia del proyecto, mientras que git<br>
            reset saca los cambios del área de preparación y los mueve del espacio de trabajo, <br>
            sin afectar la historia del repositorio.
        </p>

    <h1>Git & GitHub | Class #9</h1>

    <h2>Flujo de trabajo básico con un repositorio remoto</h2>
        <p>
            Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu<br>
            computadora. Esto significa que no hay forma de que otros miembros del equipo trabajen en él.<br><br>

            Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben<br>
            seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.<br><br>

            Estos servidores remotos pueden estar alojados en GitHub, GitLab, BitBucket, entre<br>
            otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu<br>
            computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto.<br>
            Así, el equipo podrá descargarlos, hacer cambios y volverlos a enviar al servidor remoto para<br>
            que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.<br><br>

            Esto significa que debes aprender algunos nuevos comandos
        </p>

    <h3>Comandos para trabajo remoto con GIT</h3>
        <ul>
            <li>Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta: <b>git clone (url_del_servidor_remoto)</b> </li>
            <li>Luego de hacer <b>git add</b> y <b>git commit</b> debemos ejecutar este comando para mandar los cambios al servidor remoto: <b>git push</b> </li>
            <li>Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto): <b>git fetch</b> </li>
            <li>También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo: <b>git merge</b> </li>
            <li>Básicamente, <b>git fetch</b> y <b>git merge</b> al mismo tiempo: <b>git pull</b> </li>
        </ul>

        <p>
            Adicionalmente, tenemos otros comandos que nos sirven para trabajar en proyectos muy grandes:
        </p>
        
        <ul>
            <li>Te muestra el id commit y el título del commit: <b>git log --oneline</b> </li>
            <li>Te muestra donde se encuentra el head point en el log: <b>git log --decorate</b> </li>
            <li>Explica el número de líneas que se cambiaron brevemente: <b>git log --stat</b> </li>
            <li>Explica el número de líneas que se cambiaron y te muestra que se cambió en el contenido: <b>git log -p</b> </li>
            <li>Indica que commits ha realizado un usuario, mostrando el usuario y el título de sus commits: <b>git shortlog</b> </li>
            <li> <b>git log --graph --oneline --decorate</b> y <b>git log --pretty=format:"%cn hizo un commit %h el dia %cd"</b>: Muestra mensajes personalizados de los commits</li>
            <li>Limitamos el número de commits: <b>git log -3</b> </li>
            <p>
                Commits para localizar por fechas:
            </p>
            <li> <b>git log --after=“2018-1-2</b> </li>
            <li> <b>git log --after=“today</b> </li>
            <li> <b>git log --after=“2018-1-2” --before=“today”</b> </li> <br>
            <li>Commits hechos por autor que cumplan exactamente con el nombre: <b>git log --author=“Name Author”</b> </li>
            <li>Busca los commits que cumplan tal cual está escrito entre las comillas: <b>git log --grep=“INVIE”</b> </li>
            <li>Busca los commits que cumplan sin importar mayúsculas o minúsculas: <b>git log --grep=“INVIE” –i</b> </li>
            <li>Busca los commits en un archivo en específico: <b>git log – (nombre_del_archivo)</b> </li>
            <li>Buscar los commits con el contenido dentro del archivo: <b>git log -S “Por contenido”</b> </li>
            <li>Guardar los logs en un archivo txt: <b>git log > log.txt</b> </li>
        </ul>

    <h1>Git & GitHub | Class #10</h1>

    <h2>Introducción a las ramas o branches de Git</h2>
            <p>
                Las ramas (branches) son la forma de hacer cambios en nuestro proyecto sin afectar<br>
                el flujo de trabajo de la rama principal. Esto porque queremos trabajar una parte muy<br>
                específica de la aplicación o simplemente experimentar.<br><br>

                La cabecera o <b>HEAD</b> representan la rama y el commit de esa rama donde estamos<br>
                trabajando. Por defecto, esta cabecera aparecerá en el último commit de nuestra<br>
                rama principal. Pero podemos cambiarlo al crear una rama (<b>git branch rama</b>, <b>git checkout -b rama</b>)<br>
                o movernos en el tiempo a cualquier otro commit de cualquier otra rama con los comandos<br>
                (<b>git reset id-commit</b>, <b>git checkout rama-o-id-commit</b>).
            </p>
    
    <h3>Cómo funcionan las ramas en GIT</h3>
            <p>
                Las ramas son la manera de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de<br>
                la rama principal. Esto porque queremos trabajar una parte muy específica<br>
                de la aplicación o simplemente experimentar.
            </p>

            <ul>
                <li>Agrega los archivos al <b>Git Repository</b> desde el <b>Working Directory</b>, solo funciona si los archivos previamente se les a echo <b>git add</b> previamente: <b>git commit -am "mensaje del commit"</b> </li>
                <li>Con este comando se genera una nueva rama: <b>git branch (nombre-de-la-rama)</b> </li>
                <li>Lista todas las ramas que existen: <b>git branch -i</b> </li>
                <li>Con este comando puedes saltar de una rama a otra: <b>git checkout (nombre-de-la-rama)</b> </li>
                <li>Elimina la rama. Con <b>-D</b> se fuerza el borrado: <b>git branch -d (nombre-de-la-rama)</b> </li>
                <li>Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de git branch y git checkout al mismo tiempo: <b>git checkout -b (nombre-de-la-rama)</b> </li>
                <li>Permite renombrar una rama en una nueva rama: <b>git branch -m (nombre-de-la-rama) (nombre-de-la-nueva-rama)</b> </li>
                <li>Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag., eliminando el historial de los commit posteriores al tag seleccionado: <b>git reset (id-commit)</b> </li>
                <li>Nos lleva a cualquier commit sin borrar los commit posteriores al tag seleccionado: <b>git checkout (rama-o-id-commit)</b> </li>
            </ul>

    <h1>Git & GitHub | Class #11</h1>
    
    <h2>Fusión de ramas con Git merge</h2>
            <p>
                La fusión en Git es la forma en que este sistema une un historial bifurcado.<br>
                El comando <b>git merge</b> permite integrar líneas de desarrollo independientes generadas<br>
                por <b>git branch</b> en una sola rama. Con este comando, podemos crear un nuevo commit que combina<br>
                dos ramas o branches: la rama actual y la rama que se indica después del comando.<br><br>

                Estos comandos de fusión del merge afectan solo a la rama actual y no a la rama de destino.<br>
                Por lo tanto, te recomendamos utilizar <b>git checkout</b> para seleccionar la rama actual y <b>git branch -d</b><br>
                para eliminar la rama de destino obsoleta.
            </p>
    <h3>Funcionamiento de Git merge</h3>
            <p>
                Git merge fusiona secuencias de confirmaciones en un solo historial, generalmente para combinar<br>
                dos ramas. Busca una confirmación de base común y genera una confirmación de fusión que representa<br>
                la combinación de las dos ramas hasta el resultado final.
            </p>

    <h3>¿Cómo unir dos ramas en git?</h3>
            <p>
                Ahora bien, para combinar ramas en tu repositorio local, usa git checkout para cambiar a la rama donde deseas<br>
                fusionar. Por lo general, esta es la rama principal. Luego, emplea git merge y especifica el nombre de la otra<br>
                rama que deseas traer a esta rama. Ten en cuenta que esto es una combinación de avance rápido.
            </p>

    <h3>¿Cómo realizar un merge en git?</h3>
            <p>
                Para hacer un merge en Git, primero asegúrate de estar en la rama correcta. Después, usa el comando <b>git merge</b> seguido<br>
                del nombre de la rama que quieres combinar. Por ejemplo, si quieres crear un nuevo commit en la rama master con los<br>
                cambios de la rama cabecera, usa este comando:
            </p>

            <ul>
                <li> <b>git checkout master</b> </li>
                <li> <b>git merge cabecera</b> </li>
            </ul>

            <p>
                Es importante tener en cuenta que en caso de haber conflictos, debes guardar tus<br>
                cambios antes de hacer <b>git checkout</b> para evitar perder tu trabajo. También es recomendable<br>
                emplear los comandos básicos de GitHub, como <b>git fetch</b>, <b>git push</b> y <b>git pull</b>, para mantener actualizado tu repositorio.<br><br>

                En este ejemplo, vamos a crear un nuevo commit en la rama master combinando los cambios de una rama<br>
                llamada cabecera: Otra opción es crear un nuevo commit en la rama cabecera combinando los cambios de cualquier otra rama:<br><br>

                Git es asombroso porque puede saber cuáles cambios deben conservarse en una rama y cuáles no.<br>
                En casos de conflictos, asegúrate de guardar tus cambios antes de hacer <b>git checkout</b> para evitar perder tu trabajo.
            </p>

    <h1>Git & GitHub | Class #12</h1>
        
    <h2>Resolución de conflictos al hacer un merge</h2>
            <p>
                Git nunca borra nada, a menos que nosotros se lo indiquemos. Cuando usamos los comandos <b>git merge</b> o<br>
                <b>git checkout</b> estamos cambiando de rama o creando un nuevo commit, no borrando ramas ni commits<br>
                (recuerda que puedes borrar commits con <b>git reset</b> y ramas con <b>git branch -d</b>).<br><br>
        
                Git es muy inteligente y puede resolver algunos conflictos automáticamente: cambios, nuevas líneas, entre otros.<br>
                Pero algunas veces no sabe cómo resolver estas diferencias, por ejemplo, cuando dos ramas diferentes hacen cambio<br>
                distintos a una misma línea.<br><br>
        
                Esto lo conocemos como <b>conflicto</b> y lo podemos resolver manualmente. Solo debemos hacer el merge, ir a nuestro editor de código<br>
                y elegir si queremos quedarnos con alguna de estas dos versiones o algo diferente. Algunos editores de código como Visual Studio Code<br>
                nos ayudan a resolver estos conflictos sin necesidad de borrar o escribir líneas de texto, basta con hacer clic en un<br>
                botón y guardar el archivo.<br><br>

                Recuerda que siempre debemos crear un nuevo commit para aplicar los cambios del merge. Si Git puede resolver el<br>
                conflicto, hará commit automáticamente. Pero, en caso de no pueda resolverlo, debemos solucionarlo y hacer el commit.<br><br>
        
                Los archivos con conflictos por el comando <b>git merge</b> entran en un nuevo estado que conocemos como<br>
                <b>Unmerged</b>. Funcionan muy parecido a los archivos en estado Unstaged, algo así como un estado intermedio entre Untracked<br>
                y Unstaged. Solo debemos ejecutar <b>git add</b> para pasarlos al área de staging y <b>git commit</b> para aplicar los cambios en el repositorio.
           </p>
        
    <h3>Cómo revertir un merge</h3>
            <p>
                Si nos hemos equivocado y queremos cancelar el merge, debemos usar el siguiente comando:
            </p>
        
            <ul>
                <li> <b>git merge --abort</b> </li>
            </ul>
        
    <h3>Conflictos en repositorios remotos</h3>
            <p>
                Al trabajar con otras personas, es necesario utilizar un repositorio remoto.
            </p>
        
            <ul>
                <li>Para copiar el repositorio remoto al directorio de trabajo local, se utiliza el comando <b>git clone (url)</b>, y para enviar cambios al repositorio remoto se utiliza <b>git push</b>.</li>
                <li>Para actualizar el repositorio local se hace uso del comando <b>git fetch</b>, luego se debe fusionar los datos traídos con los locales usando <b>git merge</b>.</li> <br><br>
        
                <li>Para traer los datos y fusionarlos a la vez, en un solo comando, se usa <b>git pull</b>.</li>
                <li>Para crear commits rápidamente, fusionando <b>git add</b> y <b>git commit -m ""</b>, usamos <b>git commit -am ""</b>.</li>
                <li>Para generar nuevas ramas, hay que posicionarse sobre la rama que se desea copiar y utilizar el comando <b>git branch (nombre)</b></li>
                <li>Para saltar entre ramas, se usa el comando <b>git checkout (branch)</b></li>
                <li>Una vez realizado los cambios en la rama, estas deben fusionarse con <b>git merge</b>.</li>
            </ul>
</body>
</html>